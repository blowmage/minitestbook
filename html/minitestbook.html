<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Minitest Book</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://raw.github.com/necolas/normalize.css/master/normalize.css" type="text/css" media="screen" title="no title" charset="utf-8">
  <style>
h1{color:#000;font-size:36px;line-height:54px;}
h2{color:#111;font-size:28px;line-height:42px;}
h3{color:#111;font-size:24px;line-height:36px;}
body,p,td,div{color:#111;font-size:16px;font-family:"Liberation Sans";line-height:1.5em;font-weight: normal; word-wrap:break-word;}
h1,h2,h3,h4,h5,h6{font-family:"Liberation Sans";line-height:1.5em;margin:0.5em 0;}
ul li {line-height: 24px}
pre, code, tt { font-size:14px;line-height:24px;font-family:"Menlo" }

h1 code{font-size:34px; background-color: rgb(248, 248, 255);}
h2 code{font-size:26px; background-color: rgb(248, 248, 255);}
h3 code{font-size:22px; background-color: rgb(248, 248, 255);}
p code {font-weight: bold; background-color: rgb(248, 248, 255);}

pre code {
  display: block; padding: 0.5em;
  color: #000;
  background: #f8f8ff
}

pre .comment,
pre .template_comment,
pre .diff .header,
pre .javadoc {
  color: #998;
  font-style: italic
}

pre .keyword,
pre .css .rule .keyword,
pre .winutils,
pre .javascript .title,
pre .lisp .title,
pre .subst {
  color: #000;
  font-weight: bold
}

pre .ruby .keyword {
  font-weight: normal
}

pre .number,
pre .hexcolor {
  color: #40a070
}

pre .string,
pre .tag .value,
pre .phpdoc,
pre .tex .formula {
  color: #d14
}

pre .title,
pre .id {
  color: #900;
  font-weight: bold
}

pre .javascript .title,
pre .lisp .title,
pre .subst {
  font-weight: normal
}

pre .class .title,
pre .haskell .label,
pre .tex .command {
  color: #458;
  font-weight: bold
}

pre .class .params {
  color: #000;
}

pre .tag,
pre .tag .title,
pre .rules .property,
pre .django .tag .keyword {
  color: #000080;
  font-weight: normal
}

pre .attribute,
pre .variable,
pre .instancevar,
pre .lisp .body {
  color: #008080
}

pre .regexp {
  color: #009926
}

pre .class {
  color: #458;
  font-weight: bold
}

pre .symbol,
pre .ruby .symbol .string,
pre .ruby .symbol .keyword,
pre .ruby .symbol .keymethods,
pre .lisp .keyword,
pre .tex .special,
pre .input_number {
  color: #0086b3
}

pre .ruby .identifier .keyword,
pre .ruby .identifier .keymethods {
  color: #0086b3;
}

pre .ruby .constant {
  color: #008080;
}

pre .builtin,
pre .built_in,
pre .lisp .title {
  color: #0086b3
}

pre .preprocessor,
pre .pi,
pre .doctype,
pre .shebang,
pre .cdata {
  color: #999;
  font-weight: bold
}

pre .deletion {
  background: #fdd
}

pre .addition {
  background: #dfd
}

pre .diff .change {
  background: #0086b3
}

pre .chunk {
  color: #aaa
}

pre .tex .formula {
  opacity: 0.5;
}

.page_break {
  page-break-before: always;
}

</style>
<style>#wrapper { max-width:700px; margin:0 auto }</style>
</head>
<body class="normal">
  <div id="wrapper">
<h1><big><big>Minitest Book</big></big></h1>

<p>by Mike Moore</p>

<h2>For Reviewers:</h2>

<p>Thank you for reading this very early version of The Minitest Book. I am looking for any and all feedback. I am particularly interested in whether or not the structure of the book works. Does it feel like a book? An online tutorial? A screencast transcript? Please let me know what you think works and what you think does not work.</p>

<p>Thanks!<br>
~Mike</p>
<div class="page_break"></div>
<h1>Table of Contents</h1>

<ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#part1">Part I - Getting Started</a>

<ul>
<li><a href="#ch1-write-a-test">Chapter 1 - Write a Test</a></li>
<li><a href="#ch2-tdd-red-green">Chapter 2 - TDD Cycle: Red and Green</a></li>
<li><a href="#ch3-minibot-rules">Chapter 3 - Minibot: Adding Rules</a></li>
<li><a href="#ch4-minibot-responses">Chapter 4 - Minibot: Responses</a></li>
<li><a href="#ch5-tdd-refactor">Chapter 5 - TDD Cycle: Refactor</a></li>
<li><a href="#ch6-tdd-refactor-redux">Chapter 6 - TDD Cycle: Refactor Redux</a></li>
<li><a href="#ch7-spec-dsl">Chapter 7 - Minitest::Spec DSL</a></li>
</ul></li>
<li>Part II - Extending Minibot

<ul>
<li>Chapter 8 - ???</li>
</ul></li>
<li>Part III - Extending Minitest

<ul>
<li>Chapter 16 - ???</li>
</ul></li>
<li>Reference

<ul>
<li><a href="#appendix/assertions">Appendix A - Assertions</a></li>
<li><a href="#appendix/api-changes">Appendix B - API Changes</a></li>
</ul></li>
</ul>
<div class="page_break"></div>
<h1>Preface</h1>

<p>This book is written for Minitest 5.0 using Ruby 2.0. If you are using Ruby 1.9 or 2.0 you already have a version of Minitest that comes with Ruby, but it isn&rsquo;t 5.0. But getting the latest Minitest is very straightforward. First we need to use rubygems to install the latest minitest:</p>

<pre><code>$ gem install minitest
Fetching: minitest-5.0.6.gem (100%)
Successfully installed minitest-5.0.6
1 gem installed
</code></pre>
<div class="page_break"></div>
<h1>Introduction</h1>

<h2>Why Testing?</h2>

<p>Have you ever had to maintain an application or library and were utterly and completely unable to make sense of it? Have you ever tried to add a feature to an existing codebase but every change you made broke the app in multiple places? Have you noticed that the older a codebase is the harder it is to make changes? Have you ever found yourself several days into a task only to come to the conclusion that the available documentation and comments in the code were horribly outdated at best and incompetent at worst?</p>

<p>I&rsquo;ve done all of that. And I&rsquo;ve done it to teammates and myself. I used to think that if I could get better at thinking like a computer or acquire a deeper understanding of design patterns I could cure myself (and others) from making such a mess in the code. But these approaches only addressed the surface issues. The core problem was that the code I was working in and contributing was lacking design. Not necessarily lacking design on the high-level architecture scale, but at the micro scale. Lines and methods. Which, coincidentally, is where we spend most of our time.</p>

<h2>Why Minitest?</h2>

<p>Minitest is a full-featured testing library that comes in Ruby&rsquo;s standard library. It provides the classical testing API, a spec DSL, mocks, stubs, and performance testing. Minitest is fast. Not only in running tests, but in writing and maintaining them. Minitest is also a considerably smaller codebase than other testing libraries, which means its easier to understand and extend.</p>

<p>Minitest also carries a philosophy that informs it&rsquo;s design. Like Ruby, it acknowledges that there is usually more than one way to accomplish a task. [Something about flexibility vs. guidance.] Minitest is more than a testing library. It embodies a specific philosophy for testing code. It also embodies a larger philosophy of how software should be designed. (Unix, TDD, XP) Minitest embodies these philosophies, but that doesn&rsquo;t mean you can&rsquo;t use Minitest if you have a different view. Minitest is intended to be used, and so it doesn&rsquo;t force these views on you. But, if you are receptive, you will find Minitest is a great ally.</p>

<h2>Versions</h2>

<p>This book is written using Ruby 2 and Minitest 5. Ruby 2 comes with Minitest 4.3.2, which means you will have to install the latest Minitest from rubygems.</p>

<pre><code class="shell">$ gem install minitest
Fetching: minitest-5.0.6.gem (100%)
Successfully installed minitest-5.0.6
1 gem installed
</code></pre>

<p>Some details are different between Minitest 5 and 4.3.2, but the general approach is the same.</p>
<div if="part1" class="page_break"></div>
<h1>Part I - Getting Started</h1>

<p>EXPLAIN WHAT IS COVERED IN PART I HERE.</p>
<div id="ch1-write-a-test" class="page_break"></div>
<h1>Write a Test</h1>

<p>When you get right down to it, Minitest is pretty simple. If you are familiar with testing software it does what you would expect, and if you are new to testing software it is easy to learn thanks to its small surface area. That isn&rsquo;t to say Minitest isn&rsquo;t powerful, or full featured, just that it was designed to do it&rsquo;s job and to get out of the way. Writing tests with Minitest is easy. And, as it turns out, pretty fun.</p>

<p>There are four main steps to writing tests using Minitest:</p>

<ol>
<li>Create a test class</li>
<li>Create a test method</li>
<li>Call an assertion method</li>
<li>Create support methods</li>
</ol>

<p>These steps are encompassed by the <strong>Minitest API</strong>, or Application Programming Interface. You use Minitest the way you would use any other software library. The best way to learn something is to use it, not read about it. So let&rsquo;s build something! We will use Minitest and explain its features as we go.</p>

<h2>Building Minibot</h2>

<p>I love bots, all kids of bots. IRC bots. Campfire bots. Twitter bots. They make smile (for the most part). So let&rsquo;s use Minitest to help us build a bot! We don&rsquo;t want to get lost in the weeds of all the things that a bot can do, let&rsquo;s start simple. Here is a TODO list of bot features. Let&rsquo;s will work off this list and add to it as we progress.</p>

<pre><code class="plain">Minibot
=======

A simple bot for storing and matching memes.

- [ ] Match a message string to a rule
</code></pre>

<p><code>todo.md</code></p>

<p>To start with we will match a message to one of the bot&rsquo;s rules. For example, a messages that includes the word &ldquo;zomg&rdquo; in it would get an animated gif in response. If you sent the message &ldquo;ZOMG! This is cool!&rdquo;, the bot would respond &ldquo;http://i.imgur.com/49ORL0o.gif&rdquo;.</p>

<p>Right away we know we will have the following pieces of data:</p>

<table>
  <tr>
    <td><strong>trigger</strong></td><td>&ldquo;zomg&rdquo;</td>
  </tr>
  <tr>
    <td><strong>response</strong></td><td>&ldquo;http://i.imgur.com/49ORL0o.gif&rdquo;</td>
  </tr>
  <tr>
    <td><strong>message</strong></td><td>&ldquo;ZOMG! This is cool!&rdquo;</td>
  </tr>
</table>

<p>We are going to write a test <em>before</em> we write the code. This is known as <strong>test-first</strong>. If we write the code first and the test after it would be considered <strong>test-after</strong>. Test Driven Development is a test-first approach, while Quality Assurance is typically a test-after approach. We will be using test-first and write tests before code.</p>

<h2>Test Class</h2>

<p>Let&rsquo;s create a new file in our <code>test</code> directory named <code>test/test_minibot.rb</code> to hold our test code. To create a test we need to create a new class that inherits from <code>Minitest::Test</code>. This will be our <strong>Test Class</strong>. Some projects, like <a href="http://rubyonrails.org/">Ruby on Rails</a>, may provide other test classes with project-specific functionality. The testing behavior of your test class is provided by inheritance. Your test classes don&rsquo;t need to inherit directly from <code>Minitest::Test</code>, but it needs to have <code>Minitest::Test</code> in its ancestry.</p>

<p>It is common for the test class name to describe the subject of the test. Let&rsquo;s create a new test class named <code>TestMinibot</code>.</p>

<pre><code class="ruby">require &quot;minitest/autorun&quot;

class TestMinibot &lt; Minitest::Test

end
</code></pre>

<p><code>test/test_minibot.rb</code></p>

<p><aside>
<p>Earlier versions of Minitest used <code>MiniTest::Unit::TestCase</code> instead of <code>Minitest::Test</code>. They are functionally equivalent, but <code>MiniTest::Unit::TestCase</code> is deprecated. See <a href="appendix/api-changes">appendix C</a> for a more detailed description of the changes between Minitest 5 and MiniTest 4.</p>
</aside></p>

<p>This code looks pretty simple, but it actually does quite a bit. By inheriting from <code>Minitest::Test</code> our class has all the behavior it needs to run our tests. All we need to do is implement them.</p>

<h2>Test Methods</h2>

<p>We implement individual tests by creating <strong>Test Methods</strong> within out <strong>Test Class</strong>. These methods are no different that any other method, except for how they are named. They must begin with <code>test_</code> for Minitest to recognize that they are test methods and treat them as such.</p>

<p>Let&rsquo;s create a test method. Like test classes, test methods should have a descriptive name. We don&rsquo;t know what a &ldquo;minibot&rdquo; is just yet, so the only requirement is that it starts with <code>test_</code>. How about <code>test_minibot</code>?</p>

<pre><code class="ruby">require &quot;minitest/autorun&quot;

class TestMinibot &lt; Minitest::Test
  def test_match

  end
end
</code></pre>

<p><code>test/test_minibot.rb</code></p>

<p>Like our <strong>Test Class</strong>, the <strong>Test Methods</strong> are containers tests. So far we have been creating locations for the test, but haven&rsquo;t actually tested anything. One of the common approaches to a test method is <a href="http://c2.com/cgi/wiki?ArrangeActAssert">Arrange Act Assert</a>.</p>

<h3>Arrange Act Assert</h3>

<p>A test method is intended to perform a unit of work, and verify that the code behaves as expected. One way to organize this is to perform the following steps within the test method:</p>

<ol>
<li><strong>Arrange</strong> the necessary inputs and preconditions.</li>
<li><strong>Act</strong> the intended behavior.</li>
<li><strong>Assert</strong> the results are as expected.</li>
</ol>

<p>What does this mean for our &ldquo;Match a message string to a rule&rdquo; task? We need to arrange a rule in Minibot to be matched, act on Minibot to match the message with the rule, and assert that the response to the message is what we expect. Because we are doing test-first we get to decide what Minibot&rsquo;s API will be as we write this test. So we can write the code that we want to use.</p>

<p>Here is what the <em>arrange</em> step may look like, creating a new Minibot object and registering a rule for &ldquo;zomg&rdquo; trigger and response:</p>

<pre><code class="ruby">minibot = Minibot.new
minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
</code></pre>

<p>And here is what the <em>act</em> step may look like, matching the message and returning the response:</p>

<pre><code class="ruby">response = minibot.match &quot;ZOMG! This is cool!&quot;
</code></pre>

<p>To perform the <em>assert</em> step we need to use one of the many <strong>Assertion Methods</strong> that Minitest provides.</p>

<h2>Assertion Methods</h2>

<p>Minitest checks for correctness by asserting that behavior is correct. If an assertion fails then Minitest will log it as a failure. The base assertion is the <code>assert</code> method. It evaluates the value passed to it, and if the value is <code>nil</code> or <code>false</code> the assertion will fail. This is what the most basic assertion would look like:</p>

<pre><code class="ruby">assert(response == &quot;http://i.imgur.com/49ORL0o.gif&quot;)
</code></pre>

<p>In this code we are calling the <code>assert</code> method and passing it a boolean value. If the value is <code>true</code> the test will pass. If it is <code>false</code> the test will fail. We can also provide an optional second argument to describe the circumstances should the assertion fail:</p>

<pre><code class="ruby">assert(response == &quot;http://i.imgur.com/49ORL0o.gif&quot;,
       &quot;Expected #{response} to equal http://i.imgur.com/49ORL0o.gif&quot;)
</code></pre>

<p>As you might expect, a good deal of value is found in the the error message. So much so that there are special-case assertion methods that generate this message for you. The assertion method <code>assert_equal</code> provides the logic and error message for checking the equality of two variables:</p>

<pre><code class="ruby">assert_equal &quot;http://i.imgur.com/49ORL0o.gif&quot;, response
</code></pre>

<p><aside>
  <h3>Assertion argument order</h3>
  <p>The order of arguments in most specialized assertions is &ldquo;expected, actual&rdquo;, which is opposite of what you would use for variable assignment. The first argument is the value you expect, and the second is the value created earlier in the test method. This order can be the source of a good deal of confusion when learning the Minitest API. But don&rsquo;t get too frustrated, In my experience this order is internalized quicker than most expect.</p>
</aside></p>

<p>Minitest provides several additional specialied assertion methods, such as <code>assert_includes</code>, <code>assert_in_delta</code>, and <code>assert_kind_of</code>. A full list of assertions with examples is found in <a href="appendix/assertions">appendix A</a>.</p>

<p>Now that we have our test method and assertion, this is what our test file looks like:</p>

<pre><code class="ruby">require &quot;minitest/autorun&quot;

class TestMinibot &lt; Minitest::Test
  def test_match
    minibot = Minibot.new
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
    response = minibot.match &quot;ZOMG! This is cool!&quot;
    assert_equal &quot;http://i.imgur.com/49ORL0o.gif&quot;, response
  end
end
</code></pre>

<p><code>test/test_minibot.rb</code></p>

<p>So far we have introduced a <strong>Test Class</strong>, created a <strong>Test Method</strong>, used an <strong>Assertion Method</strong> to specify our expectations. But there is one last component to the Minitest API: <strong>Support Methods</strong>.</p>

<h2>Support Methods</h2>

<p>Minitest provides hook methods to execute code before and after a <em>test method</em> is run. These methods are <code>setup</code> and <code>teardown</code>, respectively. They can be used for anything from initializing common collaborators in your tests to to creating and rolling back database transactions.</p>

<pre><code class="ruby">def setup
  # I get called before every test method
end

def teardown
  # I get called after every test method
end
</code></pre>

<p>For our purpose, we can create an instance variable named <code>@minibot</code>. The <code>setup</code> method will be called before every test method, setting <code>@minibot</code> to <code>Minibot.new</code> before each test. And the <code>teardown</code> method will be called after each test, setting <code>@minibot</code> to nil. The test methods can use <code>@minibot</code> and call assertions on it.</p>

<p>This is an example of what our test file could look like using the <code>setup</code> and <code>teardown</code> support methods:</p>

<pre><code class="ruby">require &quot;minitest/autorun&quot;

class TestMinibot &lt; Minitest::Test
  def setup
    @minibot = Minibot.new
  end

  def test_match
    @minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
    response = @minibot.match &quot;ZOMG! This is cool!&quot;
    assert_equal &quot;http://i.imgur.com/49ORL0o.gif&quot;, response
  end

  def teardown
    @minibot = nil
  end
end
</code></pre>

<p><code>test/test_minibot.rb</code></p>

<p>The <code>teardown</code> method here is to illustrate how it can be used, but it isn&rsquo;t really needed for this test code to work as the value is reset in <code>setup</code>. One use for the <code>teardown</code> method would be to perform a rollback on a database transaction created in <code>setup</code>.</p>

<p>One way to improve the readability of your tests is to move shared functionality out of the test methods and into new methods. Because Minitest is using normal Ruby classes you can use all the approaches you would use to remove duplication in your test classes as you would your application classes. But be careful, the purpose of the test code is to clearly describe the application&rsquo;s API and intent, and too much indirection may hurt readability. I generally prefer a little more duplication in my tests than I prefer in my application code. I will remove duplication in my code after repeating the same logic 2-3 times, but I won&rsquo;t remove duplication in my tests until I&rsquo;ve repeated the same logic 5-7 times.</p>

<h2>Recap</h2>

<p>You&rsquo;ve created your own <strong>test class</strong>, added a <strong>test method</strong>, and called an <strong>assertion method</strong> on an object created by the <strong>support methods</strong>. Simple, right? This is really all there is to it. Tests are just classes with methods that verify the behavior of your code with assertions.</p>

<p>You are now familiar with the Minitest API. The notion of API is important: it communicates how the software is expected to be used. Your tests will also communicate how your code is expected to be used by verifying how the API works.</p>
<div id="ch2-tdd-red-green" class="page_break"></div>
<h1>TDD Cycle: Red and Green</h1>

<p>I&rsquo;ve often been asked, &ldquo;How is writing code with tests any different than just writing code?&rdquo;. This is one of my favorite questions to answer, and by the end of this chapter you will be able to answer it too.</p>

<p>Now that we are familiar with the Minitest API, let&rsquo;s take a look at how we can use Minitest to help us design our code. We will be using a practice called Test Driven Development (TDD) and the TDD Cycle. TDD is not intended to be used for quality assurance of our software; TDD is intended to be used to help us drive the design of our code. This means we want to write our tests before we write our code, and use the tests to inform what code we write.</p>

<p>If this doesn&rsquo;t make sense to you, don&rsquo;t worry, we will step through the TDD Cycle several times before we&rsquo;re done.</p>

<h2>Step 1: Make it Red</h2>

<p>In chapter 1 we adding a new <em>test method</em> for the first TODO: &ldquo;Match a message string to a rule&rdquo;. When writing this new test method we had a decision to make: What do we want the Minibot API to be for adding a rule, matching a message, and returning the response? What information do we need to provide to add the rule? How do we know that a rule was added? We need to put ourselves in the mindset of those that consume our library: how would we want to use this code? This process is key: by consuming the code first we get to change our mindset and consider what the most appropriate API should be. We are not concerned with implementation details, we are performing a <em>design</em> exercise.</p>

<p>Here is what our test file looks like now:</p>

<pre><code class="ruby">require &quot;minitest/autorun&quot;

class TestMinibot &lt; Minitest::Test
  def test_match
    minibot = Minibot.new
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
    response = minibot.match &quot;ZOMG! This is cool!&quot;
    assert_equal &quot;http://i.imgur.com/49ORL0o.gif&quot;, response
  end
end
</code></pre>

<p><code>test/test_minibot.rb</code></p>

<p>So far the only code we have written in our <em>test class</em>, so we expect our tests to fail. To run the test we pass the file to ruby:</p>

<pre><code class="shell">$ ruby test/test_minibot.rb
Run options: --seed 44520

# Running:

E

Finished in 0.000739s, 1353.1800 runs/s, 0.0000 assertions/s.

1) Error:
TestMinibot#test_match:
NameError: uninitialized constant TestMinibot::Minibot
test/test_minibot.rb:5:in `test_match&#39;

1 runs, 0 assertions, 0 failures, 1 errors, 0 skips
</code></pre>

<p><code>terminal</code></p>

<p>Interestingly, instead of generating a failure it generated an error. The error occurred because our new test method is trying to create an new object from a class that does not exist. This is okay, Minitest expects errors to happen and will display the appropriate information.</p>

<p>Handling errors is part of our design process. We want to wrote tests to use our code before we write our code. And we want to make this test pass by writing as little code as possible. Let&rsquo;s start by fixing the &lsquo;uninitialized constant TestMinibot::Minibot&rsquo; error by adding a class definition for Minibot in our &lsquo;lib/minibot.rb` file:</p>

<pre><code class="ruby">class Minibot

end
</code></pre>

<p><code>lib/minibot.rb</code></p>

<p>And requiring the class definition in our test file after the Miniitest require:</p>

<pre><code class="ruby">require &quot;minitest/autorun&quot;
require &quot;minibot&quot;
</code></pre>

<p><code>test/test_minibot.rb</code></p>

<p>That should take care of the missing constant error. To run this test now we also need to tell Ruby to load the lib directory as well as the test directory. We do this with the <code>-Ilib:test</code> option:</p>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 8675

# Running:

E

Finished in 0.000790s, 1265.8228 runs/s, 0.0000 assertions/s.

1) Error:
TestMinibot#test_match:
NoMethodError: undefined method `add&#39; for #&lt;Minibot:0x007f90f6df89f8&gt;
test/test_minibot.rb:7:in `test_match&#39;

1 runs, 0 assertions, 0 failures, 1 errors, 0 skips
</code></pre>

<p>Now we have a different error, this time because the test is calling a method that does not exist. The Minibot constant exists, but the <code>Minibot#add</code> method does not. Let&rsquo;s create the <code>add</code> the method, but not the implementation, and rerun the test:</p>

<pre><code class="ruby">class Minibot
  def add trigger, response
    # TODO: Save this data
  end
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb
Run options: --seed 4935

E

Finished in 0.000866s, 1154.7344 runs/s, 0.0000 assertions/s.

1) Error:
TestMinibot#test_match:
NoMethodError: undefined method `match&#39; for #&lt;Minibot:0x007fadc3eb87f0&gt;
test/test_minibot.rb:8:in `test_match&#39;

1 runs, 0 assertions, 0 failures, 1 errors, 0 skips
</code></pre>

<p>Another undefined method, this time for <code>Minibot#match</code>. Our test is asking the Minibot object to match a message and return a response, but that method has not yet been implemented and Minitest is telling us this. Let&rsquo;s add an empty method to clear this error:</p>

<pre><code class="ruby">class Minibot
  def add trigger, response
    # TODO: Save this data
  end

  def match message
    # TODO: Match message to triggers
  end
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb
Run options: --seed 43768

# Running:

F

Finished in 0.033050s, 30.2572 runs/s, 30.2572 assertions/s.

1) Failure:
TestMinibot#test_match [test/test_minibot.rb:9]:
--- expected
+++ actual
@@ -1 +1 @@
-&quot;http://i.imgur.com/49ORL0o.gif&quot;
+nil

1 runs, 1 assertions, 1 failures, 0 errors, 0 skips
</code></pre>

<p>Ahh, the output is slightly different. Instead of displaying an &ldquo;Error&rdquo;, Minitest is now displaying a &ldquo;Failure&rdquo;. This is considered <em>Red</em>. Before we had <em>errors</em>; classes or methods that were called by did not exist. Now we have a <em>failure</em>, the code&rsquo;s behavior does not meet the test&rsquo;s expectations. In this case, the test expected a URL value to be returned, but got nil instead. We want our tests to drive our code from error to failure to pass. Let&rsquo;s fix this failure and get our test passing.</p>

<p>Now that we are in a failure state, we can focus on moving into the passing state. Like the previous step, we want to move from failure to pass as quickly as possible. We don&rsquo;t want to get bogged down in implementation details.</p>

<p>When we were writing our tests we put ourselves in the mindset of the consumers of our code. We thought through what API we wanted to use, not just what was easy to expose. Now we are changing the code to fulfill the expectations we have placed on the API, and we need change mindset once again. instead of focusing on implementation and correctness of our code, we want to focus on how quickly we can get the tests to pass and return to the customer mindset. To do this we need to put on the personality of the Worst Programmer in the World. We want to take any and all shortcuts needed to get the test to pass, even if this means intentionally writting bad or buggy code that won&rsquo;t work outside of our tests.</p>

<h2>Step 2: Make it Green</h2>

<p>How would the Worst Programmer in the World make this test pass? Probably hard code the implementation so it matches the expectations of the test. Let&rsquo;s do this by having the <code>match</code> method return the response string that the test is expecting.</p>

<pre><code class="ruby">class Minibot
  def add trigger, response
    # TODO: Save this data
  end

  def match message
    # TODO: Refactor. Response is coupled to test.
    &quot;http://i.imgur.com/49ORL0o.gif&quot;
  end
end
</code></pre>

<p><code>lib/minibot.rb</code></p>

<p>What an awful solution! Surely Minitest wouldn&rsquo;t allow something as bad as that to pass, right?</p>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 8245

.

Finished in 0.000786s, 1272.2646 runs/s, 1272.2646 assertions/s.

1 runs, 1 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p><code>terminal</code></p>

<p>It passes! Our terrible code passes! Passing is considered <em>Green</em>. But the code feels dirty, doesn&rsquo;t it? The <code>add</code> method doesn&rsquo;t do anything and the <code>match</code> method is hardcoded to the test expectation. Surely this isn&rsquo;t how we want our code to be.</p>

<h3>No Match</h3>

<p>Time for another mindset change. We want to return to our Consumer Mindset and write more tests that flesh out more of the expected behavior. What if the message doesn&rsquo;t match the added rule? What are our expectations for <code>Minibot#add</code>? Can we add multiple rules? Can we add multiple rules on the same trigger? Let&rsquo;s find out by writing some more tests. First, let&rsquo;s add another test for what should happen when the message doesn&rsquo;t match a rule:</p>

<pre><code class="ruby">def test_no_match
  minibot = Minibot.new
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
  response = minibot.match &quot;ZOINKS! This doesn&#39;t match!&quot;
  assert_nil response
end
</code></pre>

<p>We&rsquo;ve decided that Minibot will return nil if the message doesn&rsquo;t match a rule. Running the tests now puts us back into <em>Red</em>.</p>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 2222

# Running:

.F

Finished in 0.001220s, 1639.3443 runs/s, 1639.3443 assertions/s.

1) Failure:
TestMinibot#test_no_match [test/test_minibot.rb:16]:
Expected &quot;http://i.imgur.com/49ORL0o.gif&quot; to be nil.

2 runs, 2 assertions, 1 failures, 0 errors, 0 skips
</code></pre>

<p>The <code>test_match</code> test passes, but <code>test_no_match</code> doesn&rsquo;t. We want to get back to <em>Green</em> quickly. How can we do it? Let&rsquo;s change mindset back to the Worst Programmer and find the most expedient way possible, sacrificing correctness for <strong>???</strong> In this case, we can have <code>Minibot#match</code> check for message and return the expected URL only when the message is the one from <code>test_match</code>. Let&rsquo;s try that to get this test passing:</p>

<pre><code class="ruby">def match message
  # TODO: Refactor. Response is coupled to test.
  &quot;http://i.imgur.com/49ORL0o.gif&quot; if message == &quot;ZOMG! This is cool!&quot;
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 9954

# Running:

..

Finished in 0.000816s, 2450.9804 runs/s, 2450.9804 assertions/s.

2 runs, 2 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>With this change both the <code>test_match</code> and <code>test_no_match</code> tests pass! We let the tests drive our code implementation and we are <em>Green</em> again. We are starting to describe a usable API for Minibot, but I have no confidence in this code because it is so specific to the tests.</p>

<h2>Recap</h2>

<p>The first step in TDD is to get your tests into a Red state. Tests are written with the Customer in mind, meaning they are focused on the API design and not the implementation. Any errors in your tests need to be turned into failures as quickly as possible. You want to do as little coding as possible to move from an error state to a failure state.</p>

<p>The second step in TDD is to get your tests into a Green state as quickly as possible. To do that use the Worse Programmer mindset and take any and all shortcuts necessary to get the tests passing. Think of the Red state as a game, you want to get out of Red to Green as quickly as you can. But once you are Green you want to return to Red as quickly as you can.</p>
<div id="ch3-minibot-rules" class="page_break"></div>
<h1>Minibot: Adding Rules</h1>

<p>Our goal in TDD is to move from <em>Red</em> to <em>Green</em> as quickly as possible. To move from the <em>Consumer</em> to <em>worst Programmer</em> minsets as quickly as possible. The failing test gives us guidance and direction on what to implement, and the passing test allows us to explore new areas of behavior for our code.</p>

<p>To illustrate this let&rsquo;s revisit our TODO. We can check off the initial task, but in doing so we found it neccessary to have a way to add a rule. Let&rsquo;s add a new task for adding a rule, and one for deleting a rule. We don&rsquo;t know if we will ever need to delete a rule, but we might so its a good idea to commit that to the list.</p>

<pre><code class="plain">Minibot
=======

A simple bot for storing and matching memes.

- [x] Match a message string to a rule
- [ ] Add a rule
- [ ] Remove a rule
</code></pre>

<p><code>todo.md</code></p>

<h2>Add a rule</h2>

<p>How do we test that a rule has been added? We know a rule is a &ldquo;trigger&rdquo;, that when matched will return a &ldquo;response&rdquo;. So how do we verify that a rule was added? We probably need some way of asking Minibot what triggers have been added. How does this work? What if multiple rules are added for the same trigger? What if different rules are added for different triggers?</p>

<p>Let&rsquo;s write a few tests that cover those possibilities. Minibot should return a list of the triggers added to it. Multiple rules can be added to the same trigger. And Minibot can have more than one rule added to it. Here is how these tests can be implemented:</p>

<pre><code class="ruby">def test_adding_one_rule
  minibot = Minibot.new
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;

  assert_equal 1, minibot.triggers.size
  assert_includes minibot.triggers, &quot;zomg&quot;
end

def test_adding_multiple_rules
  minibot = Minibot.new
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/KqCfQPR.gif&quot;
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/fc5LmfO.gif&quot;

  assert_equal 1, minibot.triggers.size
  assert_includes minibot.triggers, &quot;zomg&quot;
end

def test_adding_different_rules
  minibot = Minibot.new
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
  minibot.add &quot;wtf&quot;,  &quot;http://i.imgur.com/ULQl7.gif&quot;

  assert_equal 2, minibot.triggers.size
  assert_includes minibot.triggers, &quot;zomg&quot;
  assert_includes minibot.triggers, &quot;wtf&quot;
end
</code></pre>

<p>Unfortunately, all three tests fail when run.</p>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 41171

.EE.E

Finished in 0.000937s, 5336.1793 runs/s, 2134.4717 assertions/s.

1) Error:
TestMinibot#test_adding_multiple_rules:
NoMethodError: undefined method `triggers&#39; for #&lt;Minibot:0x007f8e4bed2368&gt;
test/test_minibot.rb:33:in `test_adding_multiple_rules&#39;

2) Error:
TestMinibot#test_adding_one_rule:
NoMethodError: undefined method `triggers&#39; for #&lt;Minibot:0x007f8e4bed12d8&gt;
test/test_minibot.rb:23:in `test_adding_one_rule&#39;

3) Error:
TestMinibot#test_adding_different_rules:
NoMethodError: undefined method `triggers&#39; for #&lt;Minibot:0x007f8e4bed12d8&gt;
test/test_minibot.rb:42:in `test_adding_different_rules&#39;

5 runs, 2 assertions, 0 failures, 3 errors, 0 skips
</code></pre>

<p>Our goal is to be <em>Green</em> as quickly as possible, but we can only focus on one test at a time. To help us focus on ust one test, let&rsquo;s skip the latter test by calling <code>skip</code> within them:</p>

<pre><code class="ruby">def test_adding_multiple_rules
  skip &quot;Skipping adding multiple for now&quot;

  minibot = Minibot.new
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/KqCfQPR.gif&quot;
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/fc5LmfO.gif&quot;

  assert_equal 1, minibot.triggers.size
  assert_includes minibot.triggers, &quot;zomg&quot;
end

def test_adding_different_rules
  skip &quot;Skipping adding different for now&quot;

  minibot = Minibot.new
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
  minibot.add &quot;wtf&quot;,  &quot;http://i.imgur.com/ULQl7.gif&quot;

  assert_equal 2, minibot.triggers.size
  assert_includes minibot.triggers, &quot;zomg&quot;
  assert_includes minibot.triggers, &quot;wtf&quot;
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 14649

ESS..

Finished in 0.000963s, 5192.1080 runs/s, 2076.8432 assertions/s.

1) Error:
TestMinibot#test_adding_one_rule:
NoMethodError: undefined method `triggers&#39; for #&lt;Minibot:0x007f9643ed31a0&gt;
test/test_minibot.rb:23:in `test_adding_one_rule&#39;

5 runs, 2 assertions, 0 failures, 1 errors, 2 skips
</code></pre>

<p>Now we can focus on getting <code>test_adding_one_rule</code> passing. This test is failing because it is making a call to <code>Minibot#triggers</code>, which doesn&rsquo;t exist yet. Let&rsquo;s add this method and rerun the tests:</p>

<pre><code class="ruby">class Minibot
  def add trigger, response
    # TODO: Save this data
  end

  def match message
    # TODO: Refactor. Response is coupled to test.
    &quot;http://i.imgur.com/49ORL0o.gif&quot; if message == &quot;ZOMG! This is cool!&quot;
  end

  def triggers
    # TODO: Return all the added triggers
  end
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 8097

# Running:

ESS..

Finished in 0.000993s, 5035.2467 runs/s, 2014.0987 assertions/s.

1) Error:
TestMinibot#test_adding_one_rule:
NoMethodError: undefined method `size&#39; for nil:NilClass
test/test_minibot.rb:23:in `test_adding_one_rule&#39;

5 runs, 2 assertions, 0 failures, 1 errors, 2 skips
</code></pre>

<p>As we may have expected, another error. It may feel uncomfortable to generate this many errors, but this is an important part of TDD. We want feedback so we know what to do next. Feedback on what our code is doing gives us confidence. If we had started implementation without tests who knows what we would be implementing now. There is safety in letting the tests drive our implementation because we are only implementing what we know needs to be added.</p>

<p>Let&rsquo;s add an object that responds to <code>size</code> from the <code>Minibot#triggers</code> method to clear this error. We should expect that <code>triggers</code> is going to return a list of triggers, so let&rsquo;s return an empty array and see if our test output changes.</p>

<pre><code class="ruby">def triggers
  # TODO: Return all the added triggers
  []
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 25885

# Running:

S..FS

Finished in 0.027610s, 181.0938 runs/s, 108.6563 assertions/s.

1) Failure:
TestMinibot#test_adding_one_rule [test/test_minibot.rb:23]:
Expected: 1
Actual: 0

5 runs, 3 assertions, 1 failures, 0 errors, 2 skips
</code></pre>

<p>We have gone from <em>Error</em> to <em>Failure</em>. We know our Minibot implementation now implements the structure of the API our tests are describing, now we need to implement the behavior as well. Our tests expect the trigger &ldquo;zomg&rdquo; to be returned, so let&rsquo;s return it. Again, the Worst Programmer mindset says the fastest way to get this test to pass is to hardcode the implementation.</p>

<pre><code class="ruby">def triggers
  # TODO: Return all the added triggers
  [&quot;zomg&quot;]
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 51218

# Running:

.S..S

Finished in 0.001060s, 4716.9811 runs/s, 4716.9811 assertions/s.

5 runs, 5 assertions, 0 failures, 0 errors, 2 skips
</code></pre>

<p>Success! We are back to <em>Green</em>! Let&rsquo;s remove the <code>skip</code> call from the <code>test_adding_multiple_rules</code> test and see if it also passes:</p>

<pre><code class="ruby">def test_adding_multiple_rules
  minibot = Minibot.new
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/KqCfQPR.gif&quot;
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/fc5LmfO.gif&quot;

  assert_equal 1, minibot.triggers.size
  assert_includes minibot.triggers, &quot;zomg&quot;
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 2163

# Running:

S....

Finished in 0.000962s, 5197.5052 runs/s, 8316.0083 assertions/s.

5 runs, 8 assertions, 0 failures, 0 errors, 1 skips
</code></pre>

<p>It passes and our Worst Programmer mindset is happy because there are no changes needed. Let;s remove the last <code>skip</code> from the <code>test_adding_different_rules</code> test. Looking at the implementation I expect this test to fail.</p>

<pre><code class="ruby">def test_adding_different_rules
  minibot = Minibot.new
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
  minibot.add &quot;wtf&quot;,  &quot;http://i.imgur.com/ULQl7.gif&quot;

  assert_equal 2, minibot.triggers.size
  assert_includes minibot.triggers, &quot;zomg&quot;
  assert_includes minibot.triggers, &quot;wtf&quot;
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 49489

F....

Finished in 0.020623s, 242.4478 runs/s, 436.4060 assertions/s.

1) Failure:
TestMinibot#test_adding_different_rules [test/test_minibot.rb:42]:
Expected: 2
Actual: 1

5 runs, 9 assertions, 1 failures, 0 errors, 0 skips
</code></pre>

<p>The goal is to quickly get back to Green. But here is where I struggle. I want to take a few minites and think through the possibilities for how to implement this. My Engineering mindset starts to take over. But you need to push that away. Now is not the time for thinking about implementation. We are focusing on the Consumer API and using the rapid Red/Green feedback to help us design that API. There is no time for contemplating implementation now. So with a renewed focus let&rsquo;s figure out how to get the <code>test_adding_different_rules</code> test to pass as quickly as possible.</p>

<p>We know we want to return only the triggers sent to Minibot. So let&rsquo;s store the triggers in an <code>@triggers</code> instance variable and return them in the <code>Minibot#triggers</code> method:</p>

<pre><code class="ruby">class Minibot
  def add trigger, response
    @triggers ||= []
    @triggers &lt;&lt; trigger
  end

  def match message
    # TODO: Refactor. Response is coupled to test.
    &quot;http://i.imgur.com/49ORL0o.gif&quot; if message == &quot;ZOMG! This is cool!&quot;
  end

  def triggers
    @triggers
  end
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 38859

# Running:

.F...

Finished in 0.019181s, 260.6746 runs/s, 573.4842 assertions/s.

1) Failure:
TestMinibot#test_adding_multiple_rules [test/test_minibot.rb:33]:
Expected: 1
Actual: 3

5 runs, 11 assertions, 1 failures, 0 errors, 0 skips
</code></pre>

<p>This change gets the <code>test_adding_different_rules</code> test passing, but now the <code>test_adding_multiple_rules</code> test is failing. It is expecting one trigger for all three rules added. Again, how can we get this test passing with the least amount of code? We could return only unique triggers.</p>

<pre><code class="ruby">def triggers
  @triggers.uniq
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 4569

.....

Finished in 0.000948s, 5274.2616 runs/s, 13713.0802 assertions/s.

5 runs, 13 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>With these tests we have specified the expected behavior for adding rules to Minibot. And we have discovered more behavior around exposing a list of triggers that have been added to Minibot.</p>

<h2>Recap</h2>

<p>How do you feel about the code you&rsquo;ve written? If you are anything like me then you probably don&rsquo;t feel very good about it. You&rsquo;ve possibly been shouting down the voice inside of your head complaining about duplicate code and design patterns. The truth is, you should feel like this. The Worst Programmer mindset takes all the shortcuts I&rsquo;ve spend my career trying to avoid. This style of programming makes me feels like I&rsquo;m trolling myself. (Or trolling my pair when pair programming, which is <em>so very fun</em>.)</p>

<p>We have a few more features to design before we are done with Minibot&rsquo;s design.</p>
<div id="ch4-minibot-responses" class="page_break"></div>
<h1>Minibot: Responses</h1>

<p>In chapter 3 we used TDD to move rapidly from Red to Green on the Minibot API for adding rules. Let&rsquo;s update our TODO by marking the &ldquo;Add a rule&rdquo; task complete. We can also add a couple more tasks for listing triggers and listing a trigger&rsquo;s responses. We already have coverage for listing triggers, so let&rsquo;s mark that task as complete as well.</p>

<pre><code class="plain">Minibot
=======

A simple bot for storing and matching memes.

- [x] Match a message string to a rule
- [x] Add a rule
- [ ] Remove a rule
- [x] List triggers
- [ ] List responses for a trigger
</code></pre>

<p><code>todo.md</code></p>

<h2>List responses for a trigger</h2>

<p>Now the question is how do we allow users to list the responses for a trigger? Given the design on Minibot so far, it probably makes sense to implement a <code>Minibot#responses</code> method that takes <code>trigger</code> as an argument.</p>

<p>As we start to implement a test that uses this new method we notice a common data usage patten emerge in our tests. We can add the same three &ldquo;zomg&rdquo; rules and the one &ldquo;wtf&rdquo; rule as we have done in the other tests, and assert the responses behavior according to those rules.</p>

<pre><code class="ruby">def test_responses
  minibot = Minibot.new
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/KqCfQPR.gif&quot;
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/fc5LmfO.gif&quot;
  minibot.add &quot;wtf&quot;,  &quot;http://i.imgur.com/ULQl7.gif&quot;

  responses = minibot.responses &quot;zomg&quot;
  assert_equal 3, responses.size
  assert_includes responses, &quot;http://i.imgur.com/49ORL0o.gif&quot;
  assert_includes responses, &quot;http://i.imgur.com/KqCfQPR.gif&quot;
  assert_includes responses, &quot;http://i.imgur.com/fc5LmfO.gif&quot;

  responses = minibot.responses &quot;wtf&quot;
  assert_equal 1, responses.size
  assert_includes responses, &quot;http://i.imgur.com/ULQl7.gif&quot;
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 43364

....E.

Finished in 0.001100s, 5454.5455 runs/s, 11818.1818 assertions/s.

1) Error:
TestMinibot#test_responses:
NoMethodError: undefined method `responses&#39; for #&lt;Minibot:0x007f85a3e194e0&gt;
test/test_minibot.rb:54:in `test_responses&#39;

6 runs, 13 assertions, 0 failures, 1 errors, 0 skips
</code></pre>

<p>We are back in the error state. Let&rsquo;s add the missing <code>Minibot#responses</code> method and see if we can into the failure state. This should start to feel very familiar to you by now. Remember how foreign this felt before? Now it feels natural and comforting. The test output is telling us what we should do next.</p>

<pre><code class="ruby">def responses trigger
  # TODO: Return responses
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 46312

# Running:

.....E

Finished in 0.000962s, 6237.0062 runs/s, 13513.5135 assertions/s.

1) Error:
TestMinibot#test_responses:
NoMethodError: undefined method `size&#39; for nil:NilClass
test/test_minibot.rb:55:in `test_responses&#39;

6 runs, 13 assertions, 0 failures, 1 errors, 0 skips
</code></pre>

<p>Still in the error state. Let&rsquo;s return an object from <code>Minibot#responses</code> that has the method <code>size</code>. We can use an empty array like we have done for this error before.</p>

<pre><code class="ruby">def responses trigger
  # TODO: Return responses
  []
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 14687

# Running:

...F..

Finished in 0.027992s, 214.3470 runs/s, 500.1429 assertions/s.

1) Failure:
TestMinibot#test_responses [test/test_minibot.rb:55]:
Expected: 3
Actual: 0

6 runs, 14 assertions, 1 failures, 0 errors, 0 skips
</code></pre>

<p>Back into the failure state. Now we can start working on the behavior. We need to return a list of 3 responses when given the trigger &ldquo;zomg&rdquo;, and a list of one response when given the trigger &ldquo;wtf&rdquo;. The correct way to do this is to collect the responses as they are added, but that would require changing code in both <code>Minibot#add</code> and <code>Minibot#responses</code>. My Worst Programmer mindset thinks there is a chance I could stumble on that implementation. It is probably faster to hardcode the data in the <code>responses</code> method based on the <code>trigger</code> argument.</p>

<pre><code class="ruby">def responses trigger
  if trigger == &quot;zomg&quot;
    [ &quot;http://i.imgur.com/49ORL0o.gif&quot;,
      &quot;http://i.imgur.com/KqCfQPR.gif&quot;,
      &quot;http://i.imgur.com/fc5LmfO.gif&quot; ]
  elsif trigger == &quot;wtf&quot;
    [ &quot;http://i.imgur.com/ULQl7.gif&quot; ]
  end
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 59221

......

Finished in 0.001000s, 6000.0000 runs/s, 23000.0000 assertions/s.

6 runs, 23 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>From error to failure to passing. We can check the &ldquo;List responses for a trigger&rdquo; task as complete. The TDD Cycle we are following is working for us and we are moving faster and faster.</p>

<h2>Random Responses</h2>

<p>If we take a look at our tests, we have some good coverage for adding rules, listing triggers, and listing responses. But we don&rsquo;t have great coverage for matching responses. For instance, we don&rsquo;t specify how Minibot should behave when there are multiple responses on a matched trigger. We want Minibot to pick a random response, so let&rsquo;s write a test for that.</p>

<p>Testing random behavior is not as easy as you might think. There are always anomalies to how random Ruby&rsquo;s <code>rand</code> can be. If we matched the &ldquo;zomg&rdquo; trigger 300 times, we would expect to match all three triggers ~100 times. But in reality the actual count can vary wildly. This is where another specialized assertion method, <code>assert_in_delta</code>,  comes in handy.</p>

<p>The <code>assert_in_delta</code> method takes 3 arguments, the expected value, the actual value, and the delta that the values can vary while still passing the assertion. The default delta is 0.001, but we will need this to be larger, much larger.</p>

<p>We will run the match 300 times, and expect that all three responses are returned 100 times. But we will set the delta to be 33. So if each responses total is between 67 and 133 the test will pass.</p>

<pre><code class="ruby">def test_match_returns_random_response
  minibot = Minibot.new
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/KqCfQPR.gif&quot;
  minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/fc5LmfO.gif&quot;

  sample = 300.times.map { minibot.match &quot;ZOMG! This is cool!&quot; }
  responses = Hash[sample.group_by{|i| i }.map{|k,v| [k,v.size]}]

  assert_in_delta 100, responses[&quot;http://i.imgur.com/49ORL0o.gif&quot;], 33
  assert_in_delta 100, responses[&quot;http://i.imgur.com/KqCfQPR.gif&quot;], 33
  assert_in_delta 100, responses[&quot;http://i.imgur.com/fc5LmfO.gif&quot;], 33
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 7881

# Running:

....F..

Finished in 0.001241s, 5640.6124 runs/s, 19339.2425 assertions/s.

1) Failure:
TestMinibot#test_match_returns_random_response [test/test_minibot.rb:21]:
Expected |100 - 300| (200) to be &lt;= 33.

7 runs, 24 assertions, 1 failures, 0 errors, 0 skips
</code></pre>

<p>The <code>test_match_returns_random_response</code> test fails because we are only returning one response. We need to make <code>Minibot#match</code> return a random response instead.</p>

<pre><code class="ruby">def match message
  # TODO: Refactor. Response is coupled to test.
  if message == &quot;ZOMG! This is cool!&quot;
    responses(&quot;zomg&quot;).sample
  end
end
</code></pre>

<p>But now the <code>test_match</code> test fails most of the time:</p>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 34178

....F..

Finished in 0.027894s, 250.9500 runs/s, 932.1001 assertions/s.

  1) Failure:
TestMinibot#test_match [test/test_minibot.rb:9]:
--- expected
+++ actual
@@ -1 +1 @@
-&quot;http://i.imgur.com/49ORL0o.gif&quot;
+&quot;http://i.imgur.com/KqCfQPR.gif&quot;

7 runs, 26 assertions, 1 failures, 0 errors, 0 skips
</code></pre>

<p>Although occasionally, the test will pass:</p>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 33754

.......

Finished in 0.001362s, 5139.5007 runs/s, 19089.5742 assertions/s.

7 runs, 26 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>The <code>test_match</code> test passes occasionally because that test is only registering one rule, and is expecting only that response. It is possible change the test to make it aware of all three responses, but violates the purpose of these tests. What quick change can we make to get this test passing again?</p>

<p>We can make this test pass by capturing the responses in <code>Minibot#add</code> the same way we capture the triggers. This certainly seems like the eventual solution, but again involves changes in multiple methods. This seems to be too big of a change to make during a failing test. We want to get to Green as fast as possible, and we know that if there are more than one &ldquo;zomg&rdquo; in <code>@trigger</code> then we can use a random response. Otherwise we must use the hardcoded URL from before. So let&rsquo;s add a call to <code>@triggers.count(&quot;zomg&quot;)</code> in <code>Minibot#match</code> to determine if we return a random value or the hardcoded one.</p>

<pre><code class="ruby">def match message
  # TODO: Refactor. Response is coupled to test.
  if message == &quot;ZOMG! This is cool!&quot;
    # TODO: Remove @trigger count
    if @triggers.count(&quot;zomg&quot;) &gt; 1
      responses(&quot;zomg&quot;).sample
    else
      &quot;http://i.imgur.com/49ORL0o.gif&quot;
    end
  end
end
</code></pre>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 57173

# Running:

.......

Finished in 0.001329s, 5267.1181 runs/s, 19563.5816 assertions/s.

7 runs, 26 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>This is the worst code added so far. Nobody should feel good about this code. That pride you feel for finding a quick and elegant way to get that test passing? Squash it. That is the Worst Programmer mindset. The only good news here is that all the tests are passing, and that we now have enough test coverage to give us confidence that we can change the implementation without breaking the API. And take heart in knowing that this code will not survive the final step of the TDD Cycle: Refactoring.</p>

<h2>Recap</h2>

<p>The Customer mindset wants to ensure that the API works in the &ldquo;Make it Red&rdquo; step, but the Worst Programmer wants to ensure that we spend as little time being <em>Red</em> as possible, taking any and every shortcut to get back to <em>Green</em>. The result is a very rapid feedback cycle on the design if the API that you are providing at the cost of your code quality.</p>

<p>It should feel like you are trolling yourself. The Consumer mindset exercises your creativity by finding the edges of what is acceptable behavior for your API, while the Worst Programmer mindset exercises your critical thinking by taking every short cut possible to keep the code passing the tests. The result is rapid feedback on the design of the API, and a suite of tests that check the API implementation for correctness. The focus is all on API design and test coverage. The tests enforce the design the API. Now we are ready to move on to the final phase of the TDD Cycle.</p>
<div id="ch5-tdd-refactor" class="page_break"></div>
<h1>TDD Cycle: Refactor</h1>

<p>So far we have been racing between Red and Green, driving our code from error to failure to passing and back again. We&rsquo;ve been focusing on the API we are exposing to the consumers of our code, and intentionally not focusing on the quality of that code. We&rsquo;ve been supressing the desire to make the code right, but that is finally about to change.</p>

<h2>Step 3: Make it Right</h2>

<p>Now that the Customer and Worst Programmer mindsets have gone rounds we have a suite of tests that demonstrate the API and show how it is intended to work. Now we can focus on changing the code so that it is correct. This step is also known as the <em>Refactoring</em> step, because we want to be able to make changes to how our code is implemented without changing the API we have defined. Let&rsquo;s switch from the Consumer and Worst Programmer mindsets to the Engineer mindset and start thinking about what improvements we should make to the code. Because of our hard work so far we have some good test coverage so that we will know if we change the expected behavior the next time we run the tests.</p>

<p>Let&rsquo;s take a look at the state of our code up to this point:</p>

<pre><code class="ruby">class Minibot
  def add trigger, response
    @triggers ||= []
    @triggers &lt;&lt; trigger
  end

  def match message
    # TODO: Refactor. Response is coupled to test.
    if message == &quot;ZOMG! This is cool!&quot;
      # TODO: Remove @trigger count
      if @triggers.count(&quot;zomg&quot;) &gt; 1
        responses(&quot;zomg&quot;).sample
      else
        &quot;http://i.imgur.com/49ORL0o.gif&quot;
      end
    end
  end

  def triggers
    @triggers.uniq
  end

  def responses trigger
    if trigger == &quot;zomg&quot;
      [ &quot;http://i.imgur.com/49ORL0o.gif&quot;,
        &quot;http://i.imgur.com/KqCfQPR.gif&quot;,
        &quot;http://i.imgur.com/fc5LmfO.gif&quot; ]
    elsif trigger == &quot;wtf&quot;
      [ &quot;http://i.imgur.com/ULQl7.gif&quot; ]
    end
  end
end
</code></pre>

<p><code>lib/minibot.rb</code></p>

<p>As I look at the state of our code, the first thing I want to change is to remove the <code>@triggers</code> list and the hardcoded responses. My Engineer mindset doesn&rsquo;t like that. How can we change the implementation without changing the API? We should collect the rules as they are added. I think a Hash with a default Array value would be perfect for this. It will return an empty array if the key does not exist in the array, and you can add values to a key.</p>

<pre><code class="ruby">rules = Hash.new { |hash, key| hash[key] = [] }

rules[&quot;zomg&quot;] #=&gt; []
rules[&quot;zomg&quot;] &lt;&lt; &quot;response 1&quot;
rules[&quot;zomg&quot;] &lt;&lt; &quot;response 2&quot;
rules[&quot;zomg&quot;] #=&gt; [&quot;response 1&quot;, &quot;response 2&quot;]

rules[&quot;wtf&quot;] #=&gt; []
rules[&quot;wtf&quot;] &lt;&lt; &quot;response A&quot;
rules[&quot;wtf&quot;] #=&gt; [&quot;response A&quot;]
</code></pre>

<p>Because the tests are passing, and we have some pretty good coverage of the API we are providing, I&rsquo;m comfortable making some significant changes to <code>lib/minibot.rb</code> to use this data structure. As long as the tests continue to pass. I think we should instantiate this hash in Minibot&rsquo;s <code>initialize</code> method, and use it to store triggers and responses.</p>

<pre><code class="ruby">class Minibot
  def initialize
    @rules = Hash.new { |hash, key| hash[key] = [] }
  end

  def add trigger, response
    @rules[trigger] &lt;&lt; response
  end

  def match message
    # TODO: Refactor. Response is coupled to test.
    if message == &quot;ZOMG! This is cool!&quot;
      @rules[&quot;zomg&quot;].sample
    end
  end

  def triggers
    @rules.keys
  end

  def responses trigger
    @rules[trigger]
  end
end
</code></pre>

<p><code>lib/minibot.rb</code></p>

<p>Much better! Does it continue to pass?</p>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 34829

# Running:

.......

Finished in 0.001313s, 5331.3024 runs/s, 19801.9802 assertions/s.

7 runs, 26 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p><code>terminal</code></p>

<p>Yep, it passes and my confidence is growing. I feel much better about the quality of the code. It&rsquo;s not perfect, as we are still coupled to the test data for matching a rule. We really should make that better as well. I&rsquo;m surprised we got this far by faking the matching of a message to a rule.</p>

<p>I think the easiest way to match a trigger to a message is to use the <code>String#include?</code> method. The only wrinkle with this is that it is case sensitive. The API we are exposing must matching triggers to messages in a case insensitive way. For now I would downcase both the message and the trigger on the check.</p>

<pre><code class="ruby">trigger = &quot;zomg&quot;
message = &quot;ZOMG! This is cool!&quot;

message.include? trigger #=&gt; false
message.downcase.include? trigger.downcase #=&gt; true
</code></pre>

<p>To match the message to the rules, let&rsquo;s iterate through the rules hash and if the trigger matches the message, return a random response. Here is what that could look like:</p>

<pre><code class="ruby">def match message
  @rules.each do |trigger, responses|
    if message.downcase.include? trigger.downcase
      return responses.sample
    end
  end
  nil
end
</code></pre>

<p>I am starting to love this code. Its clear and obvious, and I&rsquo;m very confident in it right now. Does it still pass?</p>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 9405

# Running:

.......

Finished in 0.001610s, 4347.8261 runs/s, 16149.0683 assertions/s.

7 runs, 26 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>If I had additional ideas for design patterns or other implementation details I would implement them now. But the key in this phase is to only change the code, not the tests. If you change the tests in this phase you are redesigning and not refactoring.</p>

<h2>Recap</h2>

<p>You&rsquo;ve now written tests to go from <strong>Error</strong> to <strong>Failure</strong> to <strong>Passing</strong> through TDD&rsquo;s <strong>Red</strong>, <strong>Green, **Refactor</strong> steps. The dirty little secret is that you will to <em>Red</em> <em>Green</em> <em>Red</em> <em>Green</em> <em>Red</em> <em>Green</em> and then <em>Refactor</em>. In this process the tests provide sufficent coverage for the API you design for your code&rsquo;s consumers. You then use the feedback your tests provide to make changes. The end result is you will have the confidence to make improvements to your software because you enjoy the assurance that you aren&rsquo;t breaking behavior.</p>

<p>The TDD Cycle also promotes looking at your code from difference mindsets. You look at your code from multiple perspectives, from the Consumer to the Engineer, from the Designer to the Maintainer, allowing you to entertain both your creativity and your focus/completeness/something (<strong>!!</strong>). The more you practice TDD, the better at these mindsets you get, and the better code you will write.</p>
<div id="ch6-tdd-refactor-redux" class="page_break"></div>
<h1>TDD Cycle: Refactor Redux</h1>

<p>We have iterated on our tests and driven the design of our code. We have refactored our code while keeping the tests passing, and without altering the tests. Our code is cleaner and better for this, but what about our tests?</p>

<p>Far too often the criticisms I hear about tests are that the tests themselves are too difficult or time-consuming to maintain. Your tests are part of your application&rsquo;s codebase. They have a cost the same as the rest of your code. Bad tests can cost more than the benefit they provide.</p>

<p>I think I know why this happens. It is very easy to think of your tests as write-only code. Code that is not revisited after it is first created. But nothing can be further from the truth. Your tests need as much care and thought put into them as the rest of your code. This is why I like to take a moment after refactoring my code using passing tests to refactor my tests using well designed code.</p>

<h2>Step 3: Make it Right Again</h2>

<p>Now that we are happy with the design and implementation of Minibot, we can take a look at the tests. Here is the state of our tests up to this point:</p>

<pre><code class="ruby">require &quot;minitest/autorun&quot;
require &quot;minibot&quot;

class TestMinibot &lt; Minitest::Test
  def test_match
    minibot = Minibot.new
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
    response = minibot.match &quot;ZOMG! This is cool!&quot;
    assert_equal &quot;http://i.imgur.com/49ORL0o.gif&quot;, response
  end

  def test_match_returns_random_response
    minibot = Minibot.new
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/KqCfQPR.gif&quot;
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/fc5LmfO.gif&quot;

    sample = 300.times.map { minibot.match &quot;ZOMG! This is cool!&quot; }
    responses = Hash[sample.group_by{|i| i }.map{|k,v| [k,v.size]}]

    assert_in_delta 100, responses[&quot;http://i.imgur.com/49ORL0o.gif&quot;], 33
    assert_in_delta 100, responses[&quot;http://i.imgur.com/KqCfQPR.gif&quot;], 33
    assert_in_delta 100, responses[&quot;http://i.imgur.com/fc5LmfO.gif&quot;], 33
  end

  def test_no_match
    minibot = Minibot.new
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
    response = minibot.match &quot;ZOINKS! This doesn&#39;t match!&quot;
    assert_nil response
  end

  def test_adding_one_rule
    minibot = Minibot.new
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;

    assert_equal 1, minibot.triggers.size
    assert_includes minibot.triggers, &quot;zomg&quot;
  end

  def test_adding_multiple_rules
    minibot = Minibot.new
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/KqCfQPR.gif&quot;
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/fc5LmfO.gif&quot;

    assert_equal 1, minibot.triggers.size
    assert_includes minibot.triggers, &quot;zomg&quot;
  end

  def test_adding_different_rules
    minibot = Minibot.new
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
    minibot.add &quot;wtf&quot;,  &quot;http://i.imgur.com/ULQl7.gif&quot;

    assert_equal 2, minibot.triggers.size
    assert_includes minibot.triggers, &quot;zomg&quot;
    assert_includes minibot.triggers, &quot;wtf&quot;
  end

  def test_responses
    minibot = Minibot.new
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/49ORL0o.gif&quot;
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/KqCfQPR.gif&quot;
    minibot.add &quot;zomg&quot;, &quot;http://i.imgur.com/fc5LmfO.gif&quot;
    minibot.add &quot;wtf&quot;,  &quot;http://i.imgur.com/ULQl7.gif&quot;

    responses = minibot.responses &quot;zomg&quot;
    assert_equal 3, responses.size
    assert_includes responses, &quot;http://i.imgur.com/49ORL0o.gif&quot;
    assert_includes responses, &quot;http://i.imgur.com/KqCfQPR.gif&quot;
    assert_includes responses, &quot;http://i.imgur.com/fc5LmfO.gif&quot;

    responses = minibot.responses &quot;wtf&quot;
    assert_equal 1, responses.size
    assert_includes responses, &quot;http://i.imgur.com/ULQl7.gif&quot;
  end
end
</code></pre>

<p><code>test/test_minibot.rb</code></p>

<p>There is a good amount of duplication in these tests. Enough that I want to spend a little time revising the design of the tests so that the next person that works in this code has an easier time understanding the expectations. Especially if the next person is a future me. If you to the TDD Cycle right, you will be revisiting and updating your tests <em>more</em> than you change your code.</p>

<h3>Implement <code>setup</code> method</h3>

<p>The majority of the duplication I see has to do with test setup. We are adding the same rules in nearly every test. I wonder if we could find a common set of rules for all our tests and set it in the <code>setup</code> method. How about creating a Minibot instance with the 3 &ldquo;zomg&rdquo; rules and the one &ldquo;wtf&rdquo; rule?</p>

<pre><code class="ruby">def setup
  @minibot        = Minibot.new
  @zomg_responses = [ &quot;http://i.imgur.com/49ORL0o.gif&quot;,
                      &quot;http://i.imgur.com/KqCfQPR.gif&quot;,
                      &quot;http://i.imgur.com/fc5LmfO.gif&quot; ]
  @wtf_response   =   &quot;http://i.imgur.com/ULQl7.gif&quot;

  @minibot.add &quot;zomg&quot;, @zomg_responses[0]
  @minibot.add &quot;zomg&quot;, @zomg_responses[1]
  @minibot.add &quot;zomg&quot;, @zomg_responses[2]
  @minibot.add &quot;wtf&quot;,  @wtf_response
end
</code></pre>

<h3>Improved <code>match</code> tests</h3>

<p>Now let&rsquo;s turn our attention to the <code>Minibot#match</code> tests. We have a match, a no match, and a random response test. We can change the match test to look for any response in the <code>@zomg_responses</code> array, and add another test to match the &ldquo;wtf&rdquo; rule. Here is what those tests can look like using the shared setup.</p>

<pre><code class="ruby">def test_match_zomg
  response = @minibot.match &quot;ZOMG! This is cool!&quot;
  assert_includes @zomg_responses, response
end

def test_match_wtf
  response = @minibot.match &quot;Wait, this works? WTF?&quot;
  assert_equal @wtf_response, response
end

def test_match_returns_random_response
  sample = 300.times.map { @minibot.match &quot;ZOMG! This is cool!&quot; }
  responses = Hash[sample.group_by{|i| i }.map{|k,v| [k,v.size]}]

  assert_in_delta 100, responses[@zomg_responses[0]], 25
  assert_in_delta 100, responses[@zomg_responses[1]], 25
  assert_in_delta 100, responses[@zomg_responses[2]], 25
end

def test_no_match
  response = @minibot.match &quot;ZOINKS! This doesn&#39;t match!&quot;
  assert_nil response
end
</code></pre>

<p>Much better! The tests are clearer and to the point. Most don&rsquo;t have <em>Arrange</em> steps, and provide the <em>Act</em> and <em>Assert</em> steps only. While there is some data duplication in the tests, notably the message string sent to <code>Minibot#match</code>, I&rsquo;m happy with the behavior they describe. And best of all the tests still pass cleanly:</p>

<pre><code class="shell">$ ruby -Ilib:test test/test_minibot.rb

Run options: --seed 47256

# Running:

........

Finished in 0.001475s, 5423.7288 runs/s, 18983.0508 assertions/s.

8 runs, 28 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<h3>Improved <code>add</code> tests</h3>

<p>With the shared Minibot instance, the <code>add</code> tests can be consolidated. We can also add some additional coverage, asserting that the triggers are empty when no rules have been added.</p>

<pre><code class="ruby">def test_adding_rules
  assert_equal 2, @minibot.triggers.size
  assert_includes @minibot.triggers, &quot;zomg&quot;
  assert_includes @minibot.triggers, &quot;wtf&quot;
end

def test_adding_no_rules
  @minibot = Minibot.new
  assert_equal 0, @minibot.triggers.size
  refute_includes @minibot.triggers, &quot;zomg&quot;
  refute_includes @minibot.triggers, &quot;wtf&quot;
end
</code></pre>

<h3>Improved <code>responses</code> tests</h3>

<p>The <code>responses</code> tests can be simplified as well. We can simply assert that the data entered in <code>setup</code> is the same data that is available from the Minibot object. We can add additional coverage like we did for <code>add</code>, asserting that the responses for an unadded trigger returns an empty list (and doesn&rsquo;t raise an exception).</p>

<pre><code class="ruby">def test_zomg_responses
  responses = @minibot.responses &quot;zomg&quot;
  assert_equal 3, responses.size
  assert_includes responses, @zomg_responses[0]
  assert_includes responses, @zomg_responses[1]
  assert_includes responses, @zomg_responses[2]
end

def test_wtf_responses
  responses = @minibot.responses &quot;wtf&quot;
  assert_equal 1, responses.size
  assert_includes responses, @wtf_response
end

def test_no_responses
  responses = @minibot.responses &quot;zoinks&quot;
  assert_equal 0, responses.size
end
</code></pre>

<p>Again, we should only revisit the test design after all code under test is properly refactored while passing all the tests cleanly.</p>

<h2>Recap</h2>

<p>The <em>Refactor</em> step provides an opportunity to revisit the design of all our code, both the application code and the tests we use to drive it&rsquo;s design. Don&rsquo;t be afraid of making changes to your tests. Take care of your tests and they will take care of you.</p>
<div id="ch7-spec-dsl" class="page_break"></div>
<h1>Chapter 7: Minitest Spec DSL</h1>

<p>In chapter 1 we looked at the Minitest API and using <code>Minitest::Test</code> to create <em>test classes</em> and <em>test methods</em> using <em>assertion methods</em> and <em>support methods</em>. This style of testing may seem primitive to some who prefer using a high level spec DSL instead of an API. Minitest also provides a spec DSL, but to understand the spec DSL you must first understand the Minitest API. So I encourage you to read chapter 1 if you skipped it in your excitement.</p>

<p>Using a spec DSL is also very popular with practitioners of BDD, a variation of TDD. In BDD the spec DSL is used to create tests that can read as a software specification. Minitest&rsquo;s spec DSL is built on top of Minitest&rsquo;s API and provides this abstraction with minimal DIFFERENCE(?).</p>

<p>To demonstrate the spec DSL, let&rsquo;s start with the recently refactored <code>test/test_minibot.rb</code> file. We will convert this file from using the Minitest API to the spec DSL. Here are the contents of the file we are starting with:</p>

<pre><code class="ruby">require &quot;minitest/autorun&quot;
require &quot;minibot&quot;

class TestMinibot &lt; Minitest::Test
  def setup
    @minibot        = Minibot.new
    @zomg_responses = [ &quot;http://i.imgur.com/49ORL0o.gif&quot;,
                        &quot;http://i.imgur.com/KqCfQPR.gif&quot;,
                        &quot;http://i.imgur.com/fc5LmfO.gif&quot; ]
    @wtf_response   =   &quot;http://i.imgur.com/ULQl7.gif&quot;

    @minibot.add &quot;zomg&quot;, @zomg_responses[0]
    @minibot.add &quot;zomg&quot;, @zomg_responses[1]
    @minibot.add &quot;zomg&quot;, @zomg_responses[2]
    @minibot.add &quot;wtf&quot;,  @wtf_response
  end

  def test_match_zomg
    response = @minibot.match &quot;ZOMG! This is cool!&quot;
    assert_includes @zomg_responses, response
  end

  def test_match_wtf
    response = @minibot.match &quot;Wait, this works? WTF?&quot;
    assert_equal @wtf_response, response
  end

  def test_match_returns_random_response
    sample = 300.times.map { @minibot.match &quot;ZOMG! This is cool!&quot; }
    responses = Hash[sample.group_by{|i| i }.map{|k,v| [k,v.size]}]

    assert_in_delta 100, responses[@zomg_responses[0]], 33
    assert_in_delta 100, responses[@zomg_responses[1]], 33
    assert_in_delta 100, responses[@zomg_responses[2]], 33
  end

  def test_no_match
    response = @minibot.match &quot;ZOINKS! This doesn&#39;t match!&quot;
    assert_nil response
  end

  def test_adding_rules
    assert_equal 2, @minibot.triggers.size
    assert_includes @minibot.triggers, &quot;zomg&quot;
    assert_includes @minibot.triggers, &quot;wtf&quot;
  end

  def test_adding_no_rules
    @minibot = Minibot.new
    assert_equal 0, @minibot.triggers.size
    refute_includes @minibot.triggers, &quot;zomg&quot;
    refute_includes @minibot.triggers, &quot;wtf&quot;
  end

  def test_zomg_responses
    responses = @minibot.responses &quot;zomg&quot;
    assert_equal 3, responses.size
    assert_includes responses, @zomg_responses[0]
    assert_includes responses, @zomg_responses[1]
    assert_includes responses, @zomg_responses[2]
  end

  def test_wtf_responses
    responses = @minibot.responses &quot;wtf&quot;
    assert_equal 1, responses.size
    assert_includes responses, @wtf_response
  end

  def test_no_responses
    responses = @minibot.responses &quot;zoinks&quot;
    assert_equal 0, responses.size
  end
end
</code></pre>

<p><code>test/test_minibot.rb</code></p>

<h2>The <code>describe</code> Block</h2>

<p>The spec DSL is comprised of a series of nested blocks. Instead of creating a <em>test class</em> explicitly, we can use a <strong><code>describe</code> block</strong> to do this for us. We can replace the class definition with a describe:</p>

<h3>Before</h3>

<pre><code class="ruby">class TestMinibot &lt; Minitest::Test
</code></pre>

<h3>After</h3>

<pre><code class="ruby">describe Minibot do
</code></pre>

<p>The <code>describe</code> block can be passed the constant of the class you are testing, or a string, or any object that can be converted to a string, like a symbol. But for the most part a class constant it preferred when possible.</p>

<p>We can use nested <code>describe</code> blocks to narrow the focus of our tests. This focus can be about a specific method under test, or it can be a scenario such as collaborator being valid or invalid, or permissions being present or not present. For instance, there are several <em>test methods</em> specific to the <code>match</code>, <code>add</code>, and <code>responses</code> methods. Therefire we can create nested <code>describe</code> blocks that contain those tests:</p>

<pre><code class="ruby">require &quot;minitest/autorun&quot;
require &quot;minibot&quot;

describe Minibot do
  def setup
    @minibot        = Minibot.new
    @zomg_responses = [ &quot;http://i.imgur.com/49ORL0o.gif&quot;,
                        &quot;http://i.imgur.com/KqCfQPR.gif&quot;,
                        &quot;http://i.imgur.com/fc5LmfO.gif&quot; ]
    @wtf_response   =   &quot;http://i.imgur.com/ULQl7.gif&quot;

    @minibot.add &quot;zomg&quot;, @zomg_responses[0]
    @minibot.add &quot;zomg&quot;, @zomg_responses[1]
    @minibot.add &quot;zomg&quot;, @zomg_responses[2]
    @minibot.add &quot;wtf&quot;,  @wtf_response
  end

  describe :match do
    def test_match_zomg
      response = @minibot.match &quot;ZOMG! This is cool!&quot;
      assert_includes @zomg_responses, response
    end

    def test_match_wtf
      response = @minibot.match &quot;Wait, this works? WTF?&quot;
      assert_equal @wtf_response, response
    end

    def test_match_returns_random_response
      sample = 300.times.map { @minibot.match &quot;ZOMG! This is cool!&quot; }
      responses = Hash[sample.group_by{|i| i }.map{|k,v| [k,v.size]}]

      assert_in_delta 100, responses[@zomg_responses[0]], 33
      assert_in_delta 100, responses[@zomg_responses[1]], 33
      assert_in_delta 100, responses[@zomg_responses[2]], 33
    end

    def test_no_match
      response = @minibot.match &quot;ZOINKS! This doesn&#39;t match!&quot;
      assert_nil response
    end
  end

  describe :add do
    def test_adding_rules
      assert_equal 2, @minibot.triggers.size
      assert_includes @minibot.triggers, &quot;zomg&quot;
      assert_includes @minibot.triggers, &quot;wtf&quot;
    end

    def test_adding_no_rules
      @minibot = Minibot.new
      assert_equal 0, @minibot.triggers.size
      refute_includes @minibot.triggers, &quot;zomg&quot;
      refute_includes @minibot.triggers, &quot;wtf&quot;
    end
  end

  describe :responses do
    def test_zomg_responses
      responses = @minibot.responses &quot;zomg&quot;
      assert_equal 3, responses.size
      assert_includes responses, @zomg_responses[0]
      assert_includes responses, @zomg_responses[1]
      assert_includes responses, @zomg_responses[2]
    end

    def test_wtf_responses
      responses = @minibot.responses &quot;wtf&quot;
      assert_equal 1, responses.size
      assert_includes responses, @wtf_response
    end

    def test_no_responses
      responses = @minibot.responses &quot;zoinks&quot;
      assert_equal 0, responses.size
    end
  end
end
</code></pre>

<p><code>test/test_minibot.rb</code></p>

<p>Under the covers Minitest is creating a <em>test class</em> with the contents of each <code>describe</code> block. The <em>test class</em> inherits from the <code>describe</code> block it is nested under, or the default <code>Minitest::Spec</code> class if it is not nested. So the <em>test class</em> created by the <code>describe :add</code> block inherits from the <em>test class</em> created by the <code>describe Minibot</code> block, which inherits from <code>Minitest::Spec</code> (which inherits from <code>Minitest::Test</code>).</p>

<p>The <code>describe</code> block is just another way to create a <em>test class</em> in your tests. The output of the spec DSL are objects using the Minitest API.</p>

<h2>The <code>it</code> Block</h2>

<p>You can create <em>test methods</em> using the spec DSL, just as you can create <em>test classes</em>. <em>Test methods</em> are created using the <strong><code>it</code> block</strong>, which must be nested inside of a <code>describe</code> block, the same way a <em>test method</em> must be located inside a <em>test class</em>. The <code>it</code> block takes a string that can provide more expressive description than the name of the <em>test method</em>. In our test:</p>

<pre><code class="ruby">def test_match_zomg
</code></pre>

<p>Can be written with an <code>it</code> block:</p>

<pre><code class="ruby">it &quot;matches the trigger &#39;zomg&#39;&quot; do
</code></pre>

<h3>Before</h3>

<pre><code class="ruby">describe :match do
  def test_match_zomg
    response = @minibot.match &quot;ZOMG! This is cool!&quot;
    assert_includes @zomg_responses, response
  end

  def test_match_wtf
    response = @minibot.match &quot;Wait, this works? WTF?&quot;
    assert_equal @wtf_response, response
  end

  def test_match_returns_random_response
    sample = 300.times.map { @minibot.match &quot;ZOMG! This is cool!&quot; }
    responses = Hash[sample.group_by{|i| i }.map{|k,v| [k,v.size]}]

    assert_in_delta 100, responses[@zomg_responses[0]], 33
    assert_in_delta 100, responses[@zomg_responses[1]], 33
    assert_in_delta 100, responses[@zomg_responses[2]], 33
  end

  def test_no_match
    response = @minibot.match &quot;ZOINKS! This doesn&#39;t match!&quot;
    assert_nil response
  end
end
</code></pre>

<h3>After</h3>

<pre><code class="ruby">describe :match do
  it &quot;matches the trigger &#39;zomg&#39;&quot; do
    response = @minibot.match &quot;ZOMG! This is cool!&quot;
    assert_includes @zomg_responses, response
  end

  it &quot;matches the trigger &#39;wtf&#39;&quot; do
    response = @minibot.match &quot;Wait, this works? WTF?&quot;
    assert_equal @wtf_response, response
  end

  it &quot;returns a random response&quot; do
    sample = 300.times.map { @minibot.match &quot;ZOMG! This is cool!&quot; }
    responses = Hash[sample.group_by{|i| i }.map{|k,v| [k,v.size]}]

    assert_in_delta 100, responses[@zomg_responses[0]], 33
    assert_in_delta 100, responses[@zomg_responses[1]], 33
    assert_in_delta 100, responses[@zomg_responses[2]], 33
  end

  it &quot;doesn&#39;t match an unknown trigger&quot; do
    response = @minibot.match &quot;ZOINKS! This doesn&#39;t match!&quot;
    assert_nil response
  end
end
</code></pre>

<p>Under the covers Minitest is creating a <em>test method</em> that uses the string provided to the <code>it</code> block. So the contents of the <code>it &quot;adds a single rule&quot;</code> block is used to create a method named &ldquo;<code>test_0001_adds a single rule</code>&rdquo; and contents of the <code>it &quot;adds multiple rules with different triggers&quot;</code> block is used to create a method named &ldquo;<code>test_0002_adds multiple rules with different triggers</code>&rdquo;.</p>

<p>The <code>it</code> block is just another way to create a <em>test methods</em> in your tests. The output of the spec DSL are methods using the Minitest API.</p>

<h2>Expectations</h2>

<p>Instead of passing calculated values to the main <code>assert</code> method, or using special case assertions such as <code>assert_equal</code> or <code>assert_match</code>, we can use call the assertions using an alternate API(?) called <strong>expectations</strong>.</p>

<p>The common order of arguments for assertions is expected, then actual. Consider the argument names for the <code>assert_equal</code> method as defined in Minitest:</p>

<pre><code>def assert_equal exp, act, msg = nil
  msg = message(msg, &quot;&quot;) { diff exp, act }
  assert exp == act, msg
end
</code></pre>

<p>In the assertion method the position of the arguments is important, but expectations are called on the actual value eliminating the need to remember the positioning. In our tests, the <code>assert_equal</code> assertion:</p>

<pre><code class="ruby">assert_equal 1, @minibot.triggers.size
</code></pre>

<p>Can be written with the <code>must_equal</code> expectation:</p>

<pre><code class="ruby">@minibot.triggers.size.must_equal 1
</code></pre>

<h3>Before</h3>

<pre><code class="ruby">describe :match do
  it &quot;matches the trigger &#39;zomg&#39;&quot; do
    response = @minibot.match &quot;ZOMG! This is cool!&quot;
    assert_includes @zomg_responses, response
  end

  it &quot;matches the trigger &#39;wtf&#39;&quot; do
    response = @minibot.match &quot;Wait, this works? WTF?&quot;
    assert_equal @wtf_response, response
  end

  it &quot;returns a random response&quot; do
    sample = 300.times.map { @minibot.match &quot;ZOMG! This is cool!&quot; }
    responses = Hash[sample.group_by{|i| i }.map{|k,v| [k,v.size]}]

    assert_in_delta 100, responses[@zomg_responses[0]], 33
    assert_in_delta 100, responses[@zomg_responses[1]], 33
    assert_in_delta 100, responses[@zomg_responses[2]], 33
  end

  it &quot;doesn&#39;t match an unknown trigger&quot; do
    response = @minibot.match &quot;ZOINKS! This doesn&#39;t match!&quot;
    assert_nil response
  end
end
</code></pre>

<h3>After</h3>

<pre><code class="ruby">describe :match do
  it &quot;matches the trigger &#39;zomg&#39;&quot; do
    response = @minibot.match &quot;ZOMG! This is cool!&quot;
    @zomg_responses.must_include response
  end

  it &quot;matches the trigger &#39;wtf&#39;&quot; do
    response = @minibot.match &quot;Wait, this works? WTF?&quot;
    response.must_equal @wtf_response
  end

  it &quot;returns a random response&quot; do
    sample = 300.times.map { @minibot.match &quot;ZOMG! This is cool!&quot; }
    responses = Hash[sample.group_by{|i| i }.map{|k,v| [k,v.size]}]

    responses[@zomg_responses[0]].must_be_close_to 100, 33
    responses[@zomg_responses[1]].must_be_close_to 100, 33
    responses[@zomg_responses[2]].must_be_close_to 100, 33
  end

  it &quot;doesn&#39;t match an unknown trigger&quot; do
    response = @minibot.match &quot;ZOINKS! This doesn&#39;t match!&quot;
    response.must_be_nil
  end
end
</code></pre>

<p><code>test/test_minibot.rb</code></p>

<p>Under the covers Minitest is calling <em>assertion methods</em> from the <em>expectations</em>. <em>Expectations</em> are just another way to call <em>assertion methods</em> in your tests. The output of the spec DSL are methods using the Minitest API.</p>

<h2>The <code>before</code> and <code>after</code> Blocks</h2>

<p>The spec DSL has analogs for the <code>setup</code> and <code>teardown</code> support methods. They are expressed as <code>before</code> and <code>after</code> blocks. The contents of the <code>setup</code> and <code>teardown</code> support methods will transfer directly to the <code>before</code> and <code>after</code> blocks.</p>

<h3>Before</h3>

<pre><code class="ruby">def setup
  @minibot        = Minibot.new
  @zomg_responses = [ &quot;http://i.imgur.com/49ORL0o.gif&quot;,
                      &quot;http://i.imgur.com/KqCfQPR.gif&quot;,
                      &quot;http://i.imgur.com/fc5LmfO.gif&quot; ]
  @wtf_response   =   &quot;http://i.imgur.com/ULQl7.gif&quot;

  @minibot.add &quot;zomg&quot;, @zomg_responses[0]
  @minibot.add &quot;zomg&quot;, @zomg_responses[1]
  @minibot.add &quot;zomg&quot;, @zomg_responses[2]
  @minibot.add &quot;wtf&quot;,  @wtf_response
end
</code></pre>

<h3>After</h3>

<pre><code class="ruby">before do
  @minibot        = Minibot.new
  @zomg_responses = [ &quot;http://i.imgur.com/49ORL0o.gif&quot;,
                      &quot;http://i.imgur.com/KqCfQPR.gif&quot;,
                      &quot;http://i.imgur.com/fc5LmfO.gif&quot; ]
  @wtf_response   =   &quot;http://i.imgur.com/ULQl7.gif&quot;

  @minibot.add &quot;zomg&quot;, @zomg_responses[0]
  @minibot.add &quot;zomg&quot;, @zomg_responses[1]
  @minibot.add &quot;zomg&quot;, @zomg_responses[2]
  @minibot.add &quot;wtf&quot;,  @wtf_response
end
</code></pre>

<h2>The <code>let</code> Block</h2>

<p>Since the test was only using the <code>setup</code> and <code>teardown</code> methods to initialize an instance variable in our <em>test class</em>, the spec DSL provides a way to declare this outside of the the <code>before</code> and <code>after</code> blocks. This is the <code>let</code> block.</p>

<p>The <code>let</code> block will create a support method that returns the result of the given block. And it will execute the block only once per test. So while it can be called several times in a test the block will only be executed the first time. And unlike the <code>setup</code> method or the <code>before</code> block it is lazy evaluated so if it is never called the block will never be invoked.</p>

<p>Under the covers the <code>let</code> block Minitest is creates a memoized accessor method that clears the value between tests. So the following test-style code:</p>

<pre><code class="ruby">def setup
  @foo = nil
end

def foo
  @foo ||= Foo.new
end

def teardown
  @foo = nil
end
</code></pre>

<p>Can be replaced with the spec-style code:</p>

<pre><code class="ruby">let(:foo) { Foo.new }
</code></pre>

<p>We can replace our use of the <code>before</code> block with a <code>let</code> block and then update all instances of the instance variable with calls to the accessor method within the test methods.</p>

<h3>Before</h3>

<pre><code class="ruby">before do
  @minibot        = Minibot.new
  @zomg_responses = [ &quot;http://i.imgur.com/49ORL0o.gif&quot;,
                      &quot;http://i.imgur.com/KqCfQPR.gif&quot;,
                      &quot;http://i.imgur.com/fc5LmfO.gif&quot; ]
  @wtf_response   =   &quot;http://i.imgur.com/ULQl7.gif&quot;

  @minibot.add &quot;zomg&quot;, @zomg_responses[0]
  @minibot.add &quot;zomg&quot;, @zomg_responses[1]
  @minibot.add &quot;zomg&quot;, @zomg_responses[2]
  @minibot.add &quot;wtf&quot;,  @wtf_response
end
</code></pre>

<h3>After</h3>

<pre><code class="ruby">let(:minibot)        { Minibot.new }
let(:zomg_responses) { [ &quot;http://i.imgur.com/49ORL0o.gif&quot;,
                         &quot;http://i.imgur.com/KqCfQPR.gif&quot;,
                         &quot;http://i.imgur.com/fc5LmfO.gif&quot; ] }
let(:wtf_response)   { &quot;http://i.imgur.com/ULQl7.gif&quot; }

before do
  minibot.add &quot;zomg&quot;, zomg_responses[0]
  minibot.add &quot;zomg&quot;, zomg_responses[1]
  minibot.add &quot;zomg&quot;, zomg_responses[2]
  minibot.add &quot;wtf&quot;,  wtf_response
end
</code></pre>

<p>One of the advantages of the <code>let</code> blocks is that they can call other let blocks. They can be used within the <code>before</code> and <code>after</code> blocks. And they are lazy evaluated, so if you have an object that is expensive to initialize but rarely used, you don&rsquo;t pay the performance penalty on the tests that don&rsquo;t call it.</p>

<p>The <code>before</code> and <code>after</code> and <code>let</code> blocks are more ways to create a <em>support methods</em> in your tests. The output of the spec DSL are methods using the Minitest API.</p>

<h2>Final Result</h2>

<p>Our revised test is now:</p>

<pre><code class="ruby">require &quot;minitest/autorun&quot;
require &quot;minibot&quot;

describe Minibot do
  let(:minibot)        { Minibot.new }
  let(:zomg_responses) { [ &quot;http://i.imgur.com/49ORL0o.gif&quot;,
                           &quot;http://i.imgur.com/KqCfQPR.gif&quot;,
                           &quot;http://i.imgur.com/fc5LmfO.gif&quot; ] }
  let(:wtf_response)   { &quot;http://i.imgur.com/ULQl7.gif&quot; }

  before do
    minibot.add &quot;zomg&quot;, zomg_responses[0]
    minibot.add &quot;zomg&quot;, zomg_responses[1]
    minibot.add &quot;zomg&quot;, zomg_responses[2]
    minibot.add &quot;wtf&quot;,  wtf_response
  end

  describe :match do
    it &quot;matches the trigger &#39;zomg&#39;&quot; do
      response = minibot.match &quot;ZOMG! This is cool!&quot;
      zomg_responses.must_include response
    end

    it &quot;matches the trigger &#39;wtf&#39;&quot; do
      response = minibot.match &quot;Wait, this works? WTF?&quot;
      response.must_equal wtf_response
    end

    it &quot;returns a random response&quot; do
      sample = 300.times.map { minibot.match &quot;ZOMG! This is cool!&quot; }
      responses = Hash[sample.group_by{|i| i }.map{|k,v| [k,v.size]}]

      responses[zomg_responses[0]].must_be_close_to 100, 33
      responses[zomg_responses[1]].must_be_close_to 100, 33
      responses[zomg_responses[2]].must_be_close_to 100, 33
    end

    it &quot;doesn&#39;t match an unknown trigger&quot; do
      response = minibot.match &quot;ZOINKS! This doesn&#39;t match!&quot;
      response.must_be_nil
    end
  end

  describe :add do
    it &quot;adds triggers for added rules&quot; do
      minibot.triggers.size.must_equal 2
      minibot.triggers.must_include &quot;zomg&quot;
      minibot.triggers.must_include &quot;wtf&quot;
    end

    it &quot;defaults to empty triggers&quot; do
      minibot = Minibot.new
      minibot.triggers.size.must_equal 0
      minibot.triggers.wont_include &quot;zomg&quot;
      minibot.triggers.wont_include &quot;wtf&quot;
    end
  end

  describe :responses do
    it &quot;knows responses for &#39;zomg&#39;&quot; do
      responses = minibot.responses &quot;zomg&quot;
      responses.size.must_equal 3
      responses.must_include zomg_responses[0]
      responses.must_include zomg_responses[1]
      responses.must_include zomg_responses[2]
    end

    it &quot;knows responses for &#39;wtf&#39;&quot; do
      responses = minibot.responses &quot;wtf&quot;
      responses.size.must_equal 1
      responses.must_include wtf_response
    end

    it &quot;returns empty responses for unknown trigger&quot; do
      responses = minibot.responses &quot;zoinks&quot;
      responses.size.must_equal 0
    end
  end
end
</code></pre>

<p>You&rsquo;ve now converted your test from the Minitest API to the spec DSL. </p>

<h2>Recap</h2>

<p>You&rsquo;ve created <em>test classes</em> using <strong><code>describe</code> blocks</strong>, created <em>test methods</em> using <strong><code>it</code> blocks</strong>, called <em>assertion methods</em> using <strong>expectations</strong>, and created <em>support methods</em> using <strong><code>before</code></strong> and <strong><code>after</code></strong> and <strong><code>let</code> blocks</strong>.</p>

<p>The spec DSL allows for an english-like/high-level abstraction for creating objects and methods using the Minitest API. Minitest tests can use a combination of the spec DSL and the Minitest API. You can use <code>it</code> blocks with <em>test classes</em>, and <em>assertions</em> with <code>let</code> blocks. The spec DSL generates objects and methods according to the Minitest API that Minitest uses.</p>
<div class="page_break"></div>
<small><pre>
Creative Commons Legal Code

Attribution-NonCommercial-NoDerivs 3.0 Unported

    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
    LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN
    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
    REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR
    DAMAGES RESULTING FROM ITS USE.

License

THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE
COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS PROTECTED BY
COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS
AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.

BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE
TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY
BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS
CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND
CONDITIONS.

1. Definitions

 a. "Adaptation" means a work based upon the Work, or upon the Work and
    other pre-existing works, such as a translation, adaptation,
    derivative work, arrangement of music or other alterations of a
    literary or artistic work, or phonogram or performance and includes
    cinematographic adaptations or any other form in which the Work may be
    recast, transformed, or adapted including in any form recognizably
    derived from the original, except that a work that constitutes a
    Collection will not be considered an Adaptation for the purpose of
    this License. For the avoidance of doubt, where the Work is a musical
    work, performance or phonogram, the synchronization of the Work in
    timed-relation with a moving image ("synching") will be considered an
    Adaptation for the purpose of this License.
 b. "Collection" means a collection of literary or artistic works, such as
    encyclopedias and anthologies, or performances, phonograms or
    broadcasts, or other works or subject matter other than works listed
    in Section 1(f) below, which, by reason of the selection and
    arrangement of their contents, constitute intellectual creations, in
    which the Work is included in its entirety in unmodified form along
    with one or more other contributions, each constituting separate and
    independent works in themselves, which together are assembled into a
    collective whole. A work that constitutes a Collection will not be
    considered an Adaptation (as defined above) for the purposes of this
    License.
 c. "Distribute" means to make available to the public the original and
    copies of the Work through sale or other transfer of ownership.
 d. "Licensor" means the individual, individuals, entity or entities that
    offer(s) the Work under the terms of this License.
 e. "Original Author" means, in the case of a literary or artistic work,
    the individual, individuals, entity or entities who created the Work
    or if no individual or entity can be identified, the publisher; and in
    addition (i) in the case of a performance the actors, singers,
    musicians, dancers, and other persons who act, sing, deliver, declaim,
    play in, interpret or otherwise perform literary or artistic works or
    expressions of folklore; (ii) in the case of a phonogram the producer
    being the person or legal entity who first fixes the sounds of a
    performance or other sounds; and, (iii) in the case of broadcasts, the
    organization that transmits the broadcast.
 f. "Work" means the literary and/or artistic work offered under the terms
    of this License including without limitation any production in the
    literary, scientific and artistic domain, whatever may be the mode or
    form of its expression including digital form, such as a book,
    pamphlet and other writing; a lecture, address, sermon or other work
    of the same nature; a dramatic or dramatico-musical work; a
    choreographic work or entertainment in dumb show; a musical
    composition with or without words; a cinematographic work to which are
    assimilated works expressed by a process analogous to cinematography;
    a work of drawing, painting, architecture, sculpture, engraving or
    lithography; a photographic work to which are assimilated works
    expressed by a process analogous to photography; a work of applied
    art; an illustration, map, plan, sketch or three-dimensional work
    relative to geography, topography, architecture or science; a
    performance; a broadcast; a phonogram; a compilation of data to the
    extent it is protected as a copyrightable work; or a work performed by
    a variety or circus performer to the extent it is not otherwise
    considered a literary or artistic work.
 g. "You" means an individual or entity exercising rights under this
    License who has not previously violated the terms of this License with
    respect to the Work, or who has received express permission from the
    Licensor to exercise rights under this License despite a previous
    violation.
 h. "Publicly Perform" means to perform public recitations of the Work and
    to communicate to the public those public recitations, by any means or
    process, including by wire or wireless means or public digital
    performances; to make available to the public Works in such a way that
    members of the public may access these Works from a place and at a
    place individually chosen by them; to perform the Work to the public
    by any means or process and the communication to the public of the
    performances of the Work, including by public digital performance; to
    broadcast and rebroadcast the Work by any means including signs,
    sounds or images.
 i. "Reproduce" means to make copies of the Work by any means including
    without limitation by sound or visual recordings and the right of
    fixation and reproducing fixations of the Work, including storage of a
    protected performance or phonogram in digital form or other electronic
    medium.

2. Fair Dealing Rights. Nothing in this License is intended to reduce,
limit, or restrict any uses free from copyright or rights arising from
limitations or exceptions that are provided for in connection with the
copyright protection under copyright law or other applicable laws.

3. License Grant. Subject to the terms and conditions of this License,
Licensor hereby grants You a worldwide, royalty-free, non-exclusive,
perpetual (for the duration of the applicable copyright) license to
exercise the rights in the Work as stated below:

 a. to Reproduce the Work, to incorporate the Work into one or more
    Collections, and to Reproduce the Work as incorporated in the
    Collections; and,
 b. to Distribute and Publicly Perform the Work including as incorporated
    in Collections.

The above rights may be exercised in all media and formats whether now
known or hereafter devised. The above rights include the right to make
such modifications as are technically necessary to exercise the rights in
other media and formats, but otherwise you have no rights to make
Adaptations. Subject to 8(f), all rights not expressly granted by Licensor
are hereby reserved, including but not limited to the rights set forth in
Section 4(d).

4. Restrictions. The license granted in Section 3 above is expressly made
subject to and limited by the following restrictions:

 a. You may Distribute or Publicly Perform the Work only under the terms
    of this License. You must include a copy of, or the Uniform Resource
    Identifier (URI) for, this License with every copy of the Work You
    Distribute or Publicly Perform. You may not offer or impose any terms
    on the Work that restrict the terms of this License or the ability of
    the recipient of the Work to exercise the rights granted to that
    recipient under the terms of the License. You may not sublicense the
    Work. You must keep intact all notices that refer to this License and
    to the disclaimer of warranties with every copy of the Work You
    Distribute or Publicly Perform. When You Distribute or Publicly
    Perform the Work, You may not impose any effective technological
    measures on the Work that restrict the ability of a recipient of the
    Work from You to exercise the rights granted to that recipient under
    the terms of the License. This Section 4(a) applies to the Work as
    incorporated in a Collection, but this does not require the Collection
    apart from the Work itself to be made subject to the terms of this
    License. If You create a Collection, upon notice from any Licensor You
    must, to the extent practicable, remove from the Collection any credit
    as required by Section 4(c), as requested.
 b. You may not exercise any of the rights granted to You in Section 3
    above in any manner that is primarily intended for or directed toward
    commercial advantage or private monetary compensation. The exchange of
    the Work for other copyrighted works by means of digital file-sharing
    or otherwise shall not be considered to be intended for or directed
    toward commercial advantage or private monetary compensation, provided
    there is no payment of any monetary compensation in connection with
    the exchange of copyrighted works.
 c. If You Distribute, or Publicly Perform the Work or Collections, You
    must, unless a request has been made pursuant to Section 4(a), keep
    intact all copyright notices for the Work and provide, reasonable to
    the medium or means You are utilizing: (i) the name of the Original
    Author (or pseudonym, if applicable) if supplied, and/or if the
    Original Author and/or Licensor designate another party or parties
    (e.g., a sponsor institute, publishing entity, journal) for
    attribution ("Attribution Parties") in Licensor's copyright notice,
    terms of service or by other reasonable means, the name of such party
    or parties; (ii) the title of the Work if supplied; (iii) to the
    extent reasonably practicable, the URI, if any, that Licensor
    specifies to be associated with the Work, unless such URI does not
    refer to the copyright notice or licensing information for the Work.
    The credit required by this Section 4(c) may be implemented in any
    reasonable manner; provided, however, that in the case of a
    Collection, at a minimum such credit will appear, if a credit for all
    contributing authors of Collection appears, then as part of these
    credits and in a manner at least as prominent as the credits for the
    other contributing authors. For the avoidance of doubt, You may only
    use the credit required by this Section for the purpose of attribution
    in the manner set out above and, by exercising Your rights under this
    License, You may not implicitly or explicitly assert or imply any
    connection with, sponsorship or endorsement by the Original Author,
    Licensor and/or Attribution Parties, as appropriate, of You or Your
    use of the Work, without the separate, express prior written
    permission of the Original Author, Licensor and/or Attribution
    Parties.
 d. For the avoidance of doubt:

     i. Non-waivable Compulsory License Schemes. In those jurisdictions in
        which the right to collect royalties through any statutory or
        compulsory licensing scheme cannot be waived, the Licensor
        reserves the exclusive right to collect such royalties for any
        exercise by You of the rights granted under this License;
    ii. Waivable Compulsory License Schemes. In those jurisdictions in
        which the right to collect royalties through any statutory or
        compulsory licensing scheme can be waived, the Licensor reserves
        the exclusive right to collect such royalties for any exercise by
        You of the rights granted under this License if Your exercise of
        such rights is for a purpose or use which is otherwise than
        noncommercial as permitted under Section 4(b) and otherwise waives
        the right to collect royalties through any statutory or compulsory
        licensing scheme; and,
   iii. Voluntary License Schemes. The Licensor reserves the right to
        collect royalties, whether individually or, in the event that the
        Licensor is a member of a collecting society that administers
        voluntary licensing schemes, via that society, from any exercise
        by You of the rights granted under this License that is for a
        purpose or use which is otherwise than noncommercial as permitted
        under Section 4(b).
 e. Except as otherwise agreed in writing by the Licensor or as may be
    otherwise permitted by applicable law, if You Reproduce, Distribute or
    Publicly Perform the Work either by itself or as part of any
    Collections, You must not distort, mutilate, modify or take other
    derogatory action in relation to the Work which would be prejudicial
    to the Original Author's honor or reputation.

5. Representations, Warranties and Disclaimer

UNLESS OTHERWISE MUTUALLY AGREED BY THE PARTIES IN WRITING, LICENSOR
OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY
KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE,
INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY,
FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF
LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS,
WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION
OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.

6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE
LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR
ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES
ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

7. Termination

 a. This License and the rights granted hereunder will terminate
    automatically upon any breach by You of the terms of this License.
    Individuals or entities who have received Collections from You under
    this License, however, will not have their licenses terminated
    provided such individuals or entities remain in full compliance with
    those licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any
    termination of this License.
 b. Subject to the above terms and conditions, the license granted here is
    perpetual (for the duration of the applicable copyright in the Work).
    Notwithstanding the above, Licensor reserves the right to release the
    Work under different license terms or to stop distributing the Work at
    any time; provided, however that any such election will not serve to
    withdraw this License (or any other license that has been, or is
    required to be, granted under the terms of this License), and this
    License will continue in full force and effect unless terminated as
    stated above.

8. Miscellaneous

 a. Each time You Distribute or Publicly Perform the Work or a Collection,
    the Licensor offers to the recipient a license to the Work on the same
    terms and conditions as the license granted to You under this License.
 b. If any provision of this License is invalid or unenforceable under
    applicable law, it shall not affect the validity or enforceability of
    the remainder of the terms of this License, and without further action
    by the parties to this agreement, such provision shall be reformed to
    the minimum extent necessary to make such provision valid and
    enforceable.
 c. No term or provision of this License shall be deemed waived and no
    breach consented to unless such waiver or consent shall be in writing
    and signed by the party to be charged with such waiver or consent.
 d. This License constitutes the entire agreement between the parties with
    respect to the Work licensed here. There are no understandings,
    agreements or representations with respect to the Work not specified
    here. Licensor shall not be bound by any additional provisions that
    may appear in any communication from You. This License may not be
    modified without the mutual written agreement of the Licensor and You.
 e. The rights granted under, and the subject matter referenced, in this
    License were drafted utilizing the terminology of the Berne Convention
    for the Protection of Literary and Artistic Works (as amended on
    September 28, 1979), the Rome Convention of 1961, the WIPO Copyright
    Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996
    and the Universal Copyright Convention (as revised on July 24, 1971).
    These rights and subject matter take effect in the relevant
    jurisdiction in which the License terms are sought to be enforced
    according to the corresponding provisions of the implementation of
    those treaty provisions in the applicable national law. If the
    standard suite of rights granted under applicable copyright law
    includes additional rights not granted under this License, such
    additional rights are deemed to be included in the License; this
    License is not intended to restrict the license of any rights under
    applicable law.


Creative Commons Notice

    Creative Commons is not a party to this License, and makes no warranty
    whatsoever in connection with the Work. Creative Commons will not be
    liable to You or any party on any legal theory for any damages
    whatsoever, including without limitation any general, special,
    incidental or consequential damages arising in connection to this
    license. Notwithstanding the foregoing two (2) sentences, if Creative
    Commons has expressly identified itself as the Licensor hereunder, it
    shall have all rights and obligations of Licensor.

    Except for the limited purpose of indicating to the public that the
    Work is licensed under the CCPL, Creative Commons does not authorize
    the use by either party of the trademark "Creative Commons" or any
    related trademark or logo of Creative Commons without the prior
    written consent of Creative Commons. Any permitted use will be in
    compliance with Creative Commons' then-current trademark usage
    guidelines, as may be published on its website or otherwise made
    available upon request from time to time. For the avoidance of doubt,
    this trademark restriction does not form part of this License.

    Creative Commons may be contacted at http://creativecommons.org/.
</pre></small>

<script>var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function c(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function j(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function g(t,s){var r="";for(var q=0;q<t.childNodes.length;q++){if(t.childNodes[q].nodeType==3){var p=t.childNodes[q].nodeValue;if(s){p=p.replace(/\n/g,"")}r+=p}else{if(t.childNodes[q].nodeName=="BR"){r+="\n"}else{r+=g(t.childNodes[q])}}}if(/MSIE [678]/.test(navigator.userAgent)){r=r.replace(/\r/g,"\n")}return r}function a(s){var q=s.className.split(/\s+/);q=q.concat(s.parentNode.className.split(/\s+/));for(var p=0;p<q.length;p++){var r=q[p].replace(/^language-/,"");if(d[r]||r=="no-highlight"){return r}}}function b(p){var q=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{q.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);q.push({event:"stop",offset:t,node:s.childNodes[r]})}}}return t})(p,0);return q}function l(y,z,x){var r=0;var w="";var t=[];function u(){if(y.length&&z.length){if(y[0].offset!=z[0].offset){return(y[0].offset<z[0].offset)?y:z}else{return z[0].event=="start"?y:z}}else{return y.length?y:z}}function s(C){var D="<"+C.nodeName.toLowerCase();for(var A=0;A<C.attributes.length;A++){var B=C.attributes[A];D+=" "+B.nodeName.toLowerCase();if(B.nodeValue!=undefined&&B.nodeValue!=false&&B.nodeValue!=null){D+='="'+m(B.nodeValue)+'"'}}return D+">"}while(y.length||z.length){var v=u().splice(0,1)[0];w+=m(x.substr(r,v.offset-r));r=v.offset;if(v.event=="start"){w+=s(v.node);t.push(v.node)}else{if(v.event=="stop"){var q=t.length;do{q--;var p=t[q];w+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);t.splice(q,1);while(q<t.length){w+=s(t[q]);q++}}}}w+=x.substr(r);return w}function i(){function p(u,t,v){if(u.compiled){return}if(!v){u.bR=c(t,u.b?u.b:"\\B|\\b");if(!u.e&&!u.eW){u.e="\\B|\\b"}if(u.e){u.eR=c(t,u.e)}}if(u.i){u.iR=c(t,u.i)}if(u.r==undefined){u.r=1}if(u.k){u.lR=c(t,u.l||hljs.IR,true)}for(var s in u.k){if(!u.k.hasOwnProperty(s)){continue}if(u.k[s] instanceof Object){u.kG=u.k}else{u.kG={keyword:u.k}}break}if(!u.c){u.c=[]}u.compiled=true;for(var r=0;r<u.c.length;r++){p(u.c[r],t,false)}if(u.starts){p(u.starts,t,false)}}for(var q in d){if(!d.hasOwnProperty(q)){continue}p(d[q].dM,d[q],true)}}function e(J,D){if(!i.called){i();i.called=true}function z(r,M){for(var L=0;L<M.c.length;L++){if(M.c[L].bR.test(r)){return M.c[L]}}}function w(L,r){if(C[L].e&&C[L].eR.test(r)){return 1}if(C[L].eW){var M=w(L-1,r);return M?M+1:0}return 0}function x(r,L){return L.iR&&L.iR.test(r)}function A(O,N){var M=[];for(var L=0;L<O.c.length;L++){M.push(O.c[L].b)}var r=C.length-1;do{if(C[r].e){M.push(C[r].e)}r--}while(C[r+1].eW);if(O.i){M.push(O.i)}return c(N,"("+M.join("|")+")",true)}function s(M,L){var N=C[C.length-1];if(!N.t){N.t=A(N,H)}N.t.lastIndex=L;var r=N.t.exec(M);if(r){return[M.substr(L,r.index-L),r[0],false]}else{return[M.substr(L),"",true]}}function p(O,r){var L=H.cI?r[0].toLowerCase():r[0];for(var N in O.kG){if(!O.kG.hasOwnProperty(N)){continue}var M=O.kG[N].hasOwnProperty(L);if(M){return[N,M]}}return false}function F(M,O){if(!O.k){return m(M)}var N="";var P=0;O.lR.lastIndex=0;var L=O.lR.exec(M);while(L){N+=m(M.substr(P,L.index-P));var r=p(O,L);if(r){t+=r[1];N+='<span class="'+r[0]+'">'+m(L[0])+"</span>"}else{N+=m(L[0])}P=O.lR.lastIndex;L=O.lR.exec(M)}N+=m(M.substr(P,M.length-P));return N}function K(r,M){if(M.sL&&d[M.sL]){var L=e(M.sL,r);t+=L.keyword_count;return L.value}else{return F(r,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){q+=L;M.buffer=""}else{if(M.eB){q+=m(r)+L;M.buffer=""}else{q+=L;M.buffer=r}}C.push(M);B+=M.r}function E(O,L,Q){var R=C[C.length-1];if(Q){q+=K(R.buffer+O,R);return false}var M=z(L,R);if(M){q+=K(R.buffer+O,R);I(M,L);return M.rB}var r=w(C.length-1,L);if(r){var N=R.cN?"</span>":"";if(R.rE){q+=K(R.buffer+O,R)+N}else{if(R.eE){q+=K(R.buffer+O,R)+N+m(L)}else{q+=K(R.buffer+O+L,R)+N}}while(r>1){N=C[C.length-2].cN?"</span>":"";q+=N;r--;C.length--}var P=C[C.length-1];C.length--;C[C.length-1].buffer="";if(P.starts){I(P.starts,"")}return R.rE}if(x(L,R)){throw"Illegal"}}var H=d[J];var C=[H.dM];var B=0;var t=0;var q="";try{var v=0;H.dM.buffer="";do{var y=s(D,v);var u=E(y[0],y[1],y[2]);v+=y[0].length;if(!u){v+=y[1].length}}while(!y[2]);if(C.length>1){throw"Illegal"}return{r:B,keyword_count:t,value:q}}catch(G){if(G=="Illegal"){return{r:0,keyword_count:0,value:m(D)}}else{throw G}}}function f(t){var r={keyword_count:0,r:0,value:m(t)};var q=r;for(var p in d){if(!d.hasOwnProperty(p)){continue}var s=e(p,t);s.language=p;if(s.keyword_count+s.r>q.keyword_count+q.r){q=s}if(s.keyword_count+s.r>r.keyword_count+r.r){q=r;r=s}}if(q.language){r.second_best=q}return r}function h(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function o(u,x,q){var y=g(u,q);var s=a(u);if(s=="no-highlight"){return}if(s){var w=e(s,y)}else{var w=f(y);s=w.language}var p=b(u);if(p.length){var r=document.createElement("pre");r.innerHTML=w.value;w.value=l(p,b(r),y)}w.value=h(w.value,x,q);var t=u.className;if(!t.match("(\\s|^)(language-)?"+s+"(\\s|$)")){t=t?(t+" "+s):s}if(/MSIE [678]/.test(navigator.userAgent)&&u.tagName=="CODE"&&u.parentNode.tagName=="PRE"){var r=u.parentNode;var v=document.createElement("div");v.innerHTML="<pre><code>"+w.value+"</code></pre>";u=v.firstChild.firstChild;v.firstChild.cN=r.cN;r.parentNode.replaceChild(v.firstChild,r)}else{u.innerHTML=w.value}u.className=t;u.result={language:s,kw:w.keyword_count,re:w.r};if(w.second_best){u.second_best={language:w.second_best.language,kw:w.second_best.keyword_count,re:w.second_best.r}}}function k(){if(k.called){return}k.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=j(r[p]);if(q){o(q,hljs.tabReplace)}}}function n(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",k,false);window.addEventListener("load",k,false)}else{if(window.attachEvent){window.attachEvent("onload",k)}else{window.onload=k}}}var d={};this.LANGUAGES=d;this.highlight=e;this.highlightAuto=f;this.fixMarkup=h;this.highlightBlock=o;this.initHighlighting=k;this.initHighlightingOnLoad=n;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0x[A-Za-z0-9]+|\\d+(\\.\\d+)?)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.inherit=function(p,s){var r={};for(var q in p){r[q]=p[q]}if(s){for(var q in s){r[q]=s[q]}}return r}}();hljs.LANGUAGES.bash=function(){var d={"true":1,"false":1};var b={cN:"variable",b:"\\$([a-zA-Z0-9_]+)\\b"};var a={cN:"variable",b:"\\$\\{(([^}])|(\\\\}))+\\}",c:[hljs.CNM]};var c={cN:"string",b:'"',e:'"',i:"\\n",c:[hljs.BE,b,a],r:0};var e={cN:"test_condition",b:"",e:"",c:[c,b,a,hljs.CNM],k:{literal:d},r:0};return{dM:{k:{keyword:{"if":1,then:1,"else":1,fi:1,"for":1,"break":1,"continue":1,"while":1,"in":1,"do":1,done:1,echo:1,exit:1,"return":1,set:1,declare:1},literal:d},c:[{cN:"shebang",b:"(#!\\/bin\\/bash)|(#!\\/bin\\/sh)",r:10},hljs.HCM,hljs.CNM,c,b,a,hljs.inherit(e,{b:"\\[ ",e:" \\]",r:0}),hljs.inherit(e,{b:"\\[\\[ ",e:" \\]\\]"})]}}}();hljs.LANGUAGES.cs={dM:{k:{"abstract":1,as:1,base:1,bool:1,"break":1,"byte":1,"case":1,"catch":1,"char":1,checked:1,"class":1,"const":1,"continue":1,decimal:1,"default":1,delegate:1,"do":1,"do":1,"double":1,"else":1,"enum":1,event:1,explicit:1,extern:1,"false":1,"finally":1,fixed:1,"float":1,"for":1,foreach:1,"goto":1,"if":1,implicit:1,"in":1,"int":1,"interface":1,internal:1,is:1,lock:1,"long":1,namespace:1,"new":1,"null":1,object:1,operator:1,out:1,override:1,params:1,"private":1,"protected":1,"public":1,readonly:1,ref:1,"return":1,sbyte:1,sealed:1,"short":1,sizeof:1,stackalloc:1,"static":1,string:1,struct:1,"switch":1,"this":1,"throw":1,"true":1,"try":1,"typeof":1,uint:1,ulong:1,unchecked:1,unsafe:1,ushort:1,using:1,virtual:1,"volatile":1,"void":1,"while":1,ascending:1,descending:1,from:1,get:1,group:1,into:1,join:1,let:1,orderby:1,partial:1,select:1,set:1,value:1,"var":1,where:1,yield:1},c:[{cN:"comment",b:"///",e:"$",rB:true,c:[{cN:"xmlDocTag",b:"///|<!--|-->"},{cN:"xmlDocTag",b:"</?",e:">"}]},hljs.CLCM,hljs.CBLCLM,{cN:"string",b:'@"',e:'"',c:[{b:'""'}]},hljs.ASM,hljs.QSM,hljs.CNM]}};hljs.LANGUAGES.ruby=function(){var g="[a-zA-Z_][a-zA-Z0-9_]*(\\!|\\?)?";var a="[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?";var n={keyword:{and:1,"false":1,then:1,defined:1,module:1,"in":1,"return":1,redo:1,"if":1,BEGIN:1,retry:1,end:1,"for":1,"true":1,self:1,when:1,next:1,until:1,"do":1,begin:1,unless:1,END:1,rescue:1,nil:1,"else":1,"break":1,undef:1,not:1,"super":1,"class":1,"case":1,require:1,yield:1,alias:1,"while":1,ensure:1,elsif:1,or:1,def:1},keymethods:{__id__:1,__send__:1,abort:1,abs:1,"all?":1,allocate:1,ancestors:1,"any?":1,arity:1,assoc:1,at:1,at_exit:1,autoload:1,"autoload?":1,"between?":1,binding:1,binmode:1,"block_given?":1,call:1,callcc:1,caller:1,capitalize:1,"capitalize!":1,casecmp:1,"catch":1,ceil:1,center:1,chomp:1,"chomp!":1,chop:1,"chop!":1,chr:1,"class":1,class_eval:1,"class_variable_defined?":1,class_variables:1,clear:1,clone:1,close:1,close_read:1,close_write:1,"closed?":1,coerce:1,collect:1,"collect!":1,compact:1,"compact!":1,concat:1,"const_defined?":1,const_get:1,const_missing:1,const_set:1,constants:1,count:1,crypt:1,"default":1,default_proc:1,"delete":1,"delete!":1,delete_at:1,delete_if:1,detect:1,display:1,div:1,divmod:1,downcase:1,"downcase!":1,downto:1,dump:1,dup:1,each:1,each_byte:1,each_index:1,each_key:1,each_line:1,each_pair:1,each_value:1,each_with_index:1,"empty?":1,entries:1,eof:1,"eof?":1,"eql?":1,"equal?":1,"eval":1,exec:1,exit:1,"exit!":1,extend:1,fail:1,fcntl:1,fetch:1,fileno:1,fill:1,find:1,find_all:1,first:1,flatten:1,"flatten!":1,floor:1,flush:1,for_fd:1,foreach:1,fork:1,format:1,freeze:1,"frozen?":1,fsync:1,getc:1,gets:1,global_variables:1,grep:1,gsub:1,"gsub!":1,"has_key?":1,"has_value?":1,hash:1,hex:1,id:1,include:1,"include?":1,included_modules:1,index:1,indexes:1,indices:1,induced_from:1,inject:1,insert:1,inspect:1,instance_eval:1,instance_method:1,instance_methods:1,"instance_of?":1,"instance_variable_defined?":1,instance_variable_get:1,instance_variable_set:1,instance_variables:1,"integer?":1,intern:1,invert:1,ioctl:1,"is_a?":1,isatty:1,"iterator?":1,join:1,"key?":1,keys:1,"kind_of?":1,lambda:1,last:1,length:1,lineno:1,ljust:1,load:1,local_variables:1,loop:1,lstrip:1,"lstrip!":1,map:1,"map!":1,match:1,max:1,"member?":1,merge:1,"merge!":1,method:1,"method_defined?":1,method_missing:1,methods:1,min:1,module_eval:1,modulo:1,name:1,nesting:1,"new":1,next:1,"next!":1,"nil?":1,nitems:1,"nonzero?":1,object_id:1,oct:1,open:1,pack:1,partition:1,pid:1,pipe:1,pop:1,popen:1,pos:1,prec:1,prec_f:1,prec_i:1,print:1,printf:1,private_class_method:1,private_instance_methods:1,"private_method_defined?":1,private_methods:1,proc:1,protected_instance_methods:1,"protected_method_defined?":1,protected_methods:1,public_class_method:1,public_instance_methods:1,"public_method_defined?":1,public_methods:1,push:1,putc:1,puts:1,quo:1,raise:1,rand:1,rassoc:1,read:1,read_nonblock:1,readchar:1,readline:1,readlines:1,readpartial:1,rehash:1,reject:1,"reject!":1,remainder:1,reopen:1,replace:1,require:1,"respond_to?":1,reverse:1,"reverse!":1,reverse_each:1,rewind:1,rindex:1,rjust:1,round:1,rstrip:1,"rstrip!":1,scan:1,seek:1,select:1,send:1,set_trace_func:1,shift:1,singleton_method_added:1,singleton_methods:1,size:1,sleep:1,slice:1,"slice!":1,sort:1,"sort!":1,sort_by:1,split:1,sprintf:1,squeeze:1,"squeeze!":1,srand:1,stat:1,step:1,store:1,strip:1,"strip!":1,sub:1,"sub!":1,succ:1,"succ!":1,sum:1,superclass:1,swapcase:1,"swapcase!":1,sync:1,syscall:1,sysopen:1,sysread:1,sysseek:1,system:1,syswrite:1,taint:1,"tainted?":1,tell:1,test:1,"throw":1,times:1,to_a:1,to_ary:1,to_f:1,to_hash:1,to_i:1,to_int:1,to_io:1,to_proc:1,to_s:1,to_str:1,to_sym:1,tr:1,"tr!":1,tr_s:1,"tr_s!":1,trace_var:1,transpose:1,trap:1,truncate:1,"tty?":1,type:1,ungetc:1,uniq:1,"uniq!":1,unpack:1,unshift:1,untaint:1,untrace_var:1,upcase:1,"upcase!":1,update:1,upto:1,"value?":1,values:1,values_at:1,warn:1,write:1,write_nonblock:1,"zero?":1,zip:1}};var h={cN:"yardoctag",b:"@[A-Za-z]+"};var d={cN:"comment",b:"#",e:"$",c:[h]};var c={cN:"comment",b:"^\\=begin",e:"^\\=end",c:[h],r:10};var b={cN:"comment",b:"^__END__",e:"\\n$"};var u={cN:"subst",b:"#\\{",e:"}",l:g,k:n};var p=[hljs.BE,u];var s={cN:"string",b:"'",e:"'",c:p,r:0};var r={cN:"string",b:'"',e:'"',c:p,r:0};var q={cN:"string",b:"%[qw]?\\(",e:"\\)",c:p,r:10};var o={cN:"string",b:"%[qw]?\\[",e:"\\]",c:p,r:10};var m={cN:"string",b:"%[qw]?{",e:"}",c:p,r:10};var l={cN:"string",b:"%[qw]?<",e:">",c:p,r:10};var k={cN:"string",b:"%[qw]?/",e:"/",c:p,r:10};var j={cN:"string",b:"%[qw]?%",e:"%",c:p,r:10};var i={cN:"string",b:"%[qw]?-",e:"-",c:p,r:10};var t={cN:"string",b:"%[qw]?\\|",e:"\\|",c:p,r:10};var e={cN:"function",b:"\\bdef\\s+",e:" |$|;",l:g,k:n,c:[{cN:"title",b:a,l:g,k:n},{cN:"params",b:"\\(",e:"\\)",l:g,k:n},d,c,b]};var f={cN:"identifier",b:g,l:g,k:n,r:0};var v=[d,c,b,s,r,q,o,m,l,k,j,i,t,{cN:"class",b:"\\b(class|module)\\b",e:"$|;",k:{"class":1,module:1},c:[{cN:"title",b:"[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?",r:0},{cN:"inheritance",b:"<\\s*",c:[{cN:"parent",b:"("+hljs.IR+"::)?"+hljs.IR}]},d,c,b]},e,{cN:"constant",b:"(::)?([A-Z]\\w*(::)?)+",r:0},{cN:"symbol",b:":",c:[s,r,q,o,m,l,k,j,i,t,f],r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{cN:"number",b:"\\?\\w"},{cN:"variable",b:"(\\$\\W)|((\\$|\\@\\@?)(\\w+))"},f,{b:"("+hljs.RSR+")\\s*",c:[d,c,b,{cN:"regexp",b:"/",e:"/[a-z]*",i:"\\n",c:[hljs.BE]}],r:0}];u.c=v;e.c[1].c=v;return{dM:{l:g,k:n,c:v}}}();hljs.LANGUAGES.diff={cI:true,dM:{c:[{cN:"chunk",b:"^\\@\\@ +\\-\\d+,\\d+ +\\+\\d+,\\d+ +\\@\\@$",r:10},{cN:"chunk",b:"^\\*\\*\\* +\\d+,\\d+ +\\*\\*\\*\\*$",r:10},{cN:"chunk",b:"^\\-\\-\\- +\\d+,\\d+ +\\-\\-\\-\\-$",r:10},{cN:"header",b:"Index: ",e:"$"},{cN:"header",b:"=====",e:"=====$"},{cN:"header",b:"^\\-\\-\\-",e:"$"},{cN:"header",b:"^\\*{3} ",e:"$"},{cN:"header",b:"^\\+\\+\\+",e:"$"},{cN:"header",b:"\\*{5}",e:"\\*{5}$"},{cN:"addition",b:"^\\+",e:"$"},{cN:"deletion",b:"^\\-",e:"$"},{cN:"change",b:"^\\!",e:"$"}]}};hljs.LANGUAGES.javascript={dM:{k:{keyword:{"in":1,"if":1,"for":1,"while":1,"finally":1,"var":1,"new":1,"function":1,"do":1,"return":1,"void":1,"else":1,"break":1,"catch":1,"instanceof":1,"with":1,"throw":1,"case":1,"default":1,"try":1,"this":1,"switch":1,"continue":1,"typeof":1,"delete":1},literal:{"true":1,"false":1,"null":1}},c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM,hljs.CNM,{b:"("+hljs.RSR+"|case|return|throw)\\s*",k:{"return":1,"throw":1,"case":1},c:[hljs.CLCM,hljs.CBLCLM,{cN:"regexp",b:"/",e:"/[gim]*",c:[{b:"\\\\/"}]}],r:0},{cN:"function",b:"\\bfunction\\b",e:"{",k:{"function":1},c:[{cN:"title",b:"[A-Za-z$_][0-9A-Za-z$_]*"},{cN:"params",b:"\\(",e:"\\)",c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM]}]}]}};hljs.LANGUAGES.css=function(){var a={cN:"function",b:hljs.IR+"\\(",e:"\\)",c:[{eW:true,eE:true,c:[hljs.NM,hljs.ASM,hljs.QSM]}]};return{cI:true,dM:{i:"[=/|']",c:[hljs.CBLCLM,{cN:"id",b:"\\#[A-Za-z0-9_-]+"},{cN:"class",b:"\\.[A-Za-z0-9_-]+",r:0},{cN:"attr_selector",b:"\\[",e:"\\]",i:"$"},{cN:"pseudo",b:":(:)?[a-zA-Z0-9\\_\\-\\+\\(\\)\\\"\\']+"},{cN:"at_rule",b:"@(font-face|page)",l:"[a-z-]+",k:{"font-face":1,page:1}},{cN:"at_rule",b:"@",e:"[{;]",eE:true,k:{"import":1,page:1,media:1,charset:1},c:[a,hljs.ASM,hljs.QSM,hljs.NM]},{cN:"tag",b:hljs.IR,r:0},{cN:"rules",b:"{",e:"}",i:"[^\\s]",r:0,c:[hljs.CBLCLM,{cN:"rule",b:"[^\\s]",rB:true,e:";",eW:true,c:[{cN:"attribute",b:"[A-Z\\_\\.\\-]+",e:":",eE:true,i:"[^\\s]",starts:{cN:"value",eW:true,eE:true,c:[a,hljs.NM,hljs.QSM,hljs.ASM,hljs.CBLCLM,{cN:"hexcolor",b:"\\#[0-9A-F]+"},{cN:"important",b:"!important"}]}}]}]}]}}}();hljs.LANGUAGES.xml=function(){var b="[A-Za-z0-9\\._:-]+";var a={eW:true,c:[{cN:"attribute",b:b,r:0},{b:'="',rB:true,e:'"',c:[{cN:"value",b:'"',eW:true}]},{b:"='",rB:true,e:"'",c:[{cN:"value",b:"'",eW:true}]},{b:"=",c:[{cN:"value",b:"[^\\s/>]+"}]}]};return{cI:true,dM:{c:[{cN:"pi",b:"<\\?",e:"\\?>",r:10},{cN:"doctype",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},{cN:"comment",b:"<!--",e:"-->",r:10},{cN:"cdata",b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"tag",b:"<style",e:">",k:{title:{style:1}},c:[a],starts:{cN:"css",e:"</style>",rE:true,sL:"css"}},{cN:"tag",b:"<script",e:">",k:{title:{script:1}},c:[a],starts:{cN:"javascript",e:"<\/script>",rE:true,sL:"javascript"}},{cN:"vbscript",b:"<%",e:"%>",sL:"vbscript"},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"title",b:"[^ />]+"},a]}]}}}();hljs.LANGUAGES.java={dM:{k:{"false":1,"synchronized":1,"int":1,"abstract":1,"float":1,"private":1,"char":1,"interface":1,"boolean":1,"static":1,"null":1,"if":1,"const":1,"for":1,"true":1,"while":1,"long":1,"throw":1,strictfp:1,"finally":1,"protected":1,"extends":1,"import":1,"native":1,"final":1,"implements":1,"return":1,"void":1,"enum":1,"else":1,"break":1,"transient":1,"new":1,"catch":1,"instanceof":1,"byte":1,"super":1,"class":1,"volatile":1,"case":1,assert:1,"short":1,"package":1,"default":1,"double":1,"public":1,"try":1,"this":1,"switch":1,"continue":1,"throws":1},c:[{cN:"javadoc",b:"/\\*\\*",e:"\\*/",c:[{cN:"javadoctag",b:"@[A-Za-z]+"}],r:10},hljs.CLCM,hljs.CBLCLM,hljs.ASM,hljs.QSM,{cN:"class",b:"(class |interface )",e:"{",k:{"class":1,"interface":1},i:":",c:[{b:"(implements|extends)",k:{"extends":1,"implements":1},r:10},{cN:"title",b:hljs.UIR}]},hljs.CNM,{cN:"annotation",b:"@[A-Za-z]+"}]}};hljs.LANGUAGES.php={cI:true,dM:{k:{and:1,include_once:1,list:1,"abstract":1,global:1,"private":1,echo:1,"interface":1,as:1,"static":1,endswitch:1,array:1,"null":1,"if":1,endwhile:1,or:1,"const":1,"for":1,endforeach:1,self:1,"var":1,"while":1,isset:1,"public":1,"protected":1,exit:1,foreach:1,"throw":1,elseif:1,"extends":1,include:1,__FILE__:1,empty:1,require_once:1,"function":1,"do":1,xor:1,"return":1,"implements":1,parent:1,clone:1,use:1,__CLASS__:1,__LINE__:1,"else":1,"break":1,print:1,"eval":1,"new":1,"catch":1,__METHOD__:1,"class":1,"case":1,exception:1,php_user_filter:1,"default":1,die:1,require:1,__FUNCTION__:1,enddeclare:1,"final":1,"try":1,"this":1,"switch":1,"continue":1,endfor:1,endif:1,declare:1,unset:1,"true":1,"false":1,namespace:1},c:[hljs.CLCM,hljs.HCM,{cN:"comment",b:"/\\*",e:"\\*/",c:[{cN:"phpdoc",b:"\\s@[A-Za-z]+",r:10}]},hljs.CNM,hljs.inherit(hljs.ASM,{i:null}),hljs.inherit(hljs.QSM,{i:null}),{cN:"variable",b:"\\$[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*"},{cN:"preprocessor",b:"<\\?php",r:10},{cN:"preprocessor",b:"\\?>"}]}};hljs.LANGUAGES.python=function(){var c={cN:"string",b:"(u|b)?r?'''",e:"'''",r:10};var b={cN:"string",b:'(u|b)?r?"""',e:'"""',r:10};var a={cN:"string",b:"(u|r|ur|b|br)'",e:"'",c:[hljs.BE],r:10};var f={cN:"string",b:'(u|r|ur|b|br)"',e:'"',c:[hljs.BE],r:10};var d={cN:"title",b:hljs.UIR};var e={cN:"params",b:"\\(",e:"\\)",c:[c,b,a,f,hljs.ASM,hljs.QSM]};return{dM:{k:{keyword:{and:1,elif:1,is:1,global:1,as:1,"in":1,"if":1,from:1,raise:1,"for":1,except:1,"finally":1,print:1,"import":1,pass:1,"return":1,exec:1,"else":1,"break":1,not:1,"with":1,"class":1,assert:1,yield:1,"try":1,"while":1,"continue":1,del:1,or:1,def:1,lambda:1,nonlocal:10},built_in:{None:1,True:1,False:1,Ellipsis:1,NotImplemented:1}},i:"(</|->|\\?)",c:[hljs.HCM,c,b,a,f,hljs.ASM,hljs.QSM,{cN:"function",b:"\\bdef ",e:":",i:"$",k:{def:1},c:[d,e],r:10},{cN:"class",b:"\\bclass ",e:":",i:"[${]",k:{"class":1},c:[d,e],r:10},hljs.CNM,{cN:"decorator",b:"@",e:"$"}]}}}();hljs.LANGUAGES.sql={cI:true,dM:{i:"[^\\s]",c:[{cN:"operator",b:"(begin|start|commit|rollback|savepoint|lock|alter|create|drop|rename|call|delete|do|handler|insert|load|replace|select|truncate|update|set|show|pragma)\\b",e:";|$",k:{keyword:{all:1,partial:1,global:1,month:1,current_timestamp:1,using:1,go:1,revoke:1,smallint:1,indicator:1,"end-exec":1,disconnect:1,zone:1,"with":1,character:1,assertion:1,to:1,add:1,current_user:1,usage:1,input:1,local:1,alter:1,match:1,collate:1,real:1,then:1,rollback:1,get:1,read:1,timestamp:1,session_user:1,not:1,integer:1,bit:1,unique:1,day:1,minute:1,desc:1,insert:1,execute:1,like:1,ilike:2,level:1,decimal:1,drop:1,"continue":1,isolation:1,found:1,where:1,constraints:1,domain:1,right:1,national:1,some:1,module:1,transaction:1,relative:1,second:1,connect:1,escape:1,close:1,system_user:1,"for":1,deferred:1,section:1,cast:1,current:1,sqlstate:1,allocate:1,intersect:1,deallocate:1,numeric:1,"public":1,preserve:1,full:1,"goto":1,initially:1,asc:1,no:1,key:1,output:1,collation:1,group:1,by:1,union:1,session:1,both:1,last:1,language:1,constraint:1,column:1,of:1,space:1,foreign:1,deferrable:1,prior:1,connection:1,unknown:1,action:1,commit:1,view:1,or:1,first:1,into:1,"float":1,year:1,primary:1,cascaded:1,except:1,restrict:1,set:1,references:1,names:1,table:1,outer:1,open:1,select:1,size:1,are:1,rows:1,from:1,prepare:1,distinct:1,leading:1,create:1,only:1,next:1,inner:1,authorization:1,schema:1,corresponding:1,option:1,declare:1,precision:1,immediate:1,"else":1,timezone_minute:1,external:1,varying:1,translation:1,"true":1,"case":1,exception:1,join:1,hour:1,"default":1,"double":1,scroll:1,value:1,cursor:1,descriptor:1,values:1,dec:1,fetch:1,procedure:1,"delete":1,and:1,"false":1,"int":1,is:1,describe:1,"char":1,as:1,at:1,"in":1,varchar:1,"null":1,trailing:1,any:1,absolute:1,current_time:1,end:1,grant:1,privileges:1,when:1,cross:1,check:1,write:1,current_date:1,pad:1,begin:1,temporary:1,exec:1,time:1,update:1,catalog:1,user:1,sql:1,date:1,on:1,identity:1,timezone_hour:1,natural:1,whenever:1,interval:1,work:1,order:1,cascade:1,diagnostics:1,nchar:1,having:1,left:1,call:1,"do":1,handler:1,load:1,replace:1,truncate:1,start:1,lock:1,show:1,pragma:1},aggregate:{count:1,sum:1,min:1,max:1,avg:1}},c:[{cN:"string",b:"'",e:"'",c:[hljs.BE,{b:"''"}],r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE,{b:'""'}],r:0},{cN:"string",b:"`",e:"`",c:[hljs.BE]},hljs.CNM,{b:"\\n"}]},hljs.CBLCLM,{cN:"comment",b:"--",e:"$"}]}};hljs.LANGUAGES.ini={cI:true,dM:{i:"[^\\s]",c:[{cN:"comment",b:";",e:"$"},{cN:"title",b:"^\\[",e:"\\]"},{cN:"setting",b:"^[a-z0-9_\\[\\]]+[ \\t]*=[ \\t]*",e:"$",c:[{cN:"value",eW:true,k:{on:1,off:1,"true":1,"false":1,yes:1,no:1},c:[hljs.QSM,hljs.NM]}]}]}};hljs.LANGUAGES.perl=function(){var c={getpwent:1,getservent:1,quotemeta:1,msgrcv:1,scalar:1,kill:1,dbmclose:1,undef:1,lc:1,ma:1,syswrite:1,tr:1,send:1,umask:1,sysopen:1,shmwrite:1,vec:1,qx:1,utime:1,local:1,oct:1,semctl:1,localtime:1,readpipe:1,"do":1,"return":1,format:1,read:1,sprintf:1,dbmopen:1,pop:1,getpgrp:1,not:1,getpwnam:1,rewinddir:1,qq:1,fileno:1,qw:1,endprotoent:1,wait:1,sethostent:1,bless:1,s:1,opendir:1,"continue":1,each:1,sleep:1,endgrent:1,shutdown:1,dump:1,chomp:1,connect:1,getsockname:1,die:1,socketpair:1,close:1,flock:1,exists:1,index:1,shmget:1,sub:1,"for":1,endpwent:1,redo:1,lstat:1,msgctl:1,setpgrp:1,abs:1,exit:1,select:1,print:1,ref:1,gethostbyaddr:1,unshift:1,fcntl:1,syscall:1,"goto":1,getnetbyaddr:1,join:1,gmtime:1,symlink:1,semget:1,splice:1,x:1,getpeername:1,recv:1,log:1,setsockopt:1,cos:1,last:1,reverse:1,gethostbyname:1,getgrnam:1,study:1,formline:1,endhostent:1,times:1,chop:1,length:1,gethostent:1,getnetent:1,pack:1,getprotoent:1,getservbyname:1,rand:1,mkdir:1,pos:1,chmod:1,y:1,substr:1,endnetent:1,printf:1,next:1,open:1,msgsnd:1,readdir:1,use:1,unlink:1,getsockopt:1,getpriority:1,rindex:1,wantarray:1,hex:1,system:1,getservbyport:1,endservent:1,"int":1,chr:1,untie:1,rmdir:1,prototype:1,tell:1,listen:1,fork:1,shmread:1,ucfirst:1,setprotoent:1,"else":1,sysseek:1,link:1,getgrgid:1,shmctl:1,waitpid:1,unpack:1,getnetbyname:1,reset:1,chdir:1,grep:1,split:1,require:1,caller:1,lcfirst:1,until:1,warn:1,"while":1,values:1,shift:1,telldir:1,getpwuid:1,my:1,getprotobynumber:1,"delete":1,and:1,sort:1,uc:1,defined:1,srand:1,accept:1,"package":1,seekdir:1,getprotobyname:1,semop:1,our:1,rename:1,seek:1,"if":1,q:1,chroot:1,sysread:1,setpwent:1,no:1,crypt:1,getc:1,chown:1,sqrt:1,write:1,setnetent:1,setpriority:1,foreach:1,tie:1,sin:1,msgget:1,map:1,stat:1,getlogin:1,unless:1,elsif:1,truncate:1,exec:1,keys:1,glob:1,tied:1,closedir:1,ioctl:1,socket:1,readlink:1,"eval":1,xor:1,readline:1,binmode:1,setservent:1,eof:1,ord:1,bind:1,alarm:1,pipe:1,atan2:1,getgrent:1,exp:1,time:1,push:1,setgrent:1,gt:1,lt:1,or:1,ne:1,m:1};var d={cN:"subst",b:"[$@]\\{",e:"}",k:c,r:10};var b={cN:"variable",b:"\\$\\d"};var a={cN:"variable",b:"[\\$\\%\\@\\*](\\^\\w\\b|#\\w+(\\:\\:\\w+)*|[^\\s\\w{]|{\\w+}|\\w+(\\:\\:\\w*)*)"};var g=[hljs.BE,d,b,a];var f={b:"->",c:[{b:hljs.IR},{b:"{",e:"}"}]};var e=[b,a,hljs.HCM,{cN:"comment",b:"^(__END__|__DATA__)",e:"\\n$",r:5},f,{cN:"string",b:"q[qwxr]?\\s*\\(",e:"\\)",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\[",e:"\\]",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\{",e:"\\}",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\|",e:"\\|",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\<",e:"\\>",c:g,r:5},{cN:"string",b:"qw\\s+q",e:"q",c:g,r:5},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"string",b:'"',e:'"',c:g,r:0},{cN:"string",b:"`",e:"`",c:[hljs.BE]},{cN:"string",b:"{\\w+}",r:0},{cN:"string",b:"-?\\w+\\s*\\=\\>",r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{cN:"regexp",b:"(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*",r:10},{cN:"regexp",b:"(m|qr)?/",e:"/[a-z]*",c:[hljs.BE],r:0},{cN:"sub",b:"\\bsub\\b",e:"(\\s*\\(.*?\\))?[;{]",k:{sub:1},r:5},{cN:"operator",b:"-\\w\\b",r:0},{cN:"pod",b:"\\=\\w",e:"\\=cut"}];d.c=e;f.c[1].c=e;return{dM:{k:c,c:e}}}();hljs.LANGUAGES.cpp=function(){var b={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};var a={cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:b,r:10};a.c=[a];return{dM:{k:b,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'",e:"[^\\\\]'",i:"[^\\\\][^']"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},a]}}}();</script>

<script>hljs.initHighlightingOnLoad();</script>
    </div>
</body>
</html>